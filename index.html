<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="cris&#39;s blog">
<meta property="og:url" content="https://kyo7701.github.io/blog/index.html">
<meta property="og:site_name" content="cris&#39;s blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="cris&#39;s blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://kyo7701.github.io/blog/">





  <title>cris's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cris's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/04/30/about-jvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/04/30/about-jvm/" itemprop="url">聊聊JVM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-30T11:07:09+08:00">
                2020-04-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在讲以下内容之前，我们先通过一个思维导图了解一下本文的大致内容</p>
<p>该图片引用自<a href="https://blog.csdn.net/sheep_3/article/details/51457116" target="_blank" rel="noopener">深入理解Java虚拟机总结-思维导图</a></p>
<p>————————————————<br><img src="https://s1.ax1x.com/2020/05/06/YAMRkq.png" alt></p>
<p><img src="https://s1.ax1x.com/2020/05/06/YAMdtP.png" alt></p>
<h2 id="内存区域划分"><a href="#内存区域划分" class="headerlink" title="内存区域划分"></a>内存区域划分</h2><p>这一部分我们主要来详细了解一下运行时数据区的内容</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p><strong>特点</strong><br>线程私有区域，生命周期与线程相同</p>
<p><strong>作用</strong><br>Java虚拟机栈是描述的Java中方法执行的内存模型: 每个方法在执行的同时会创建一个栈帧(stack frame),用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法出口</strong>等信息。每一个方法调用至执行完成的时候，都对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</p>
<p><strong>局部变量表</strong>存放了各种编译器可知的基本数据类型、引用数据类型和returnAddress指令(指向了下一条字节码指令的地址)，我们平时常说的栈指的就是Java虚拟机栈里面的局部变量表的内容</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p><strong>特点</strong><br>线程私有区域<br><strong>概述</strong><br>程序计数器是一块较小的内存空间，可以看作是当前线程执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈跟Java虚拟机栈的作用是类似的，他们的区别是Java虚拟机栈执行的是Java方法，而本地方法栈执行的是虚拟机用到的Native方法</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p><strong>特点</strong><br>所有线程共享区域，开发人员关注的核心区域，垃圾收集器管理的主要区域，Java虚拟机中内存最大的一块<br><strong>概述</strong><br>该内存区块是Java虚拟机中最大的一块内存区域，在虚拟机启动时创建，几乎所有的对象实例都会在这里进行分配，根据内存回收的角度来看，现在的大多数收集器大多采用分代收集算法，所以Java堆还可以进行进一步的细分:新生代和老年代，新生代再细致一点可分为Eden空间，from survivor空间，to survivor空间。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><strong>特点</strong><br>所有线程共享区域<br><strong>概述</strong><br>方法区与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。虽然虚拟机规范把方法区作为堆的一个逻辑部分，但他还有另外的一个别名叫非堆，目的就是和Java堆进行区分</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p><strong>概述</strong><br>运行时常量池是方法区中的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后进入方法区中的运行时常量池中存放</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁的使用，也可能导致OOM异常，在JDK1.4中新加入了NIO,引入了一种基于Channel与Buffer的I/O方式，它可以通过native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，在一些场景中能显著提升性能，因为避免了再Java堆和native堆上来回复制数据</p>
<h2 id="如何判断对象已死？"><a href="#如何判断对象已死？" class="headerlink" title="如何判断对象已死？"></a>如何判断对象已死？</h2><p>在Java堆里面几乎存放着Java世界中所有的对象实例，垃圾收集器在进行垃圾回收前，第一件事情就是需要判断哪些对象还“存活”着，哪些对象已经“死去”</p>
<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器就+1，引用失效时，计数器就-1，任何时刻计数器为0的对象即不再使用的对象，即可以理解为这个对象已经“死去”了，在下次进行垃圾回收的时候，就可以将这些对象收集。引用计数实现简单，判定效率也很高，但是他很难解决对象之间的相互循环引用的问题</p>
<h3 id="根搜索算法-可达性分析算法"><a href="#根搜索算法-可达性分析算法" class="headerlink" title="根搜索算法(可达性分析算法)"></a>根搜索算法(可达性分析算法)</h3><p>通过一系列的被称为<strong>GC Roots</strong>的对象作为起始点，从这些节点开始向下进行搜索，搜索所走过的路径为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明是对象不可用的。</p>
<p>哪些对象可以用来当做GC ROOTS呢？</p>
<ul>
<li>虚拟机栈中局部变量表中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用的对象</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="复制收集算法"><a href="#复制收集算法" class="headerlink" title="复制收集算法"></a>复制收集算法</h3><p><strong>缺点</strong></p>
<ul>
<li>可用内存大小变为原来的一半</li>
<li>如果对象存活率较高，会出现大量复制，效率会降低</li>
</ul>
<p>将可用内存按容量分为大小相等的两块，每次可使用其中的一块，当一块中的内存耗尽时，对这块内存区域进行垃圾收集，将这块内存中所有还存活的对象复制到另一块，再把这块的内存区域一次性清理掉，这样每次只对整个半区进行内存回收，分配的时候就不用了考虑内存碎片的问题了</p>
<h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p><strong>缺点</strong></p>
<ul>
<li>先标记，后清除，两阶段效率都不高</li>
<li>产生大量内存碎片</li>
</ul>
<p>先标记出所有需要回收的对象，标记完成后统一进行回收，后续的垃圾收集算法都是基于这种算法进行改进而得到的，缺点是标记和清除效率都不高，并且标记清除后会有大量的不连续的内存碎片</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>与标记清除算法类似，但是不是直接清除，而是将所有可存活的对象向一端移动，然后直接清理掉边界外的内存。</p>
<h3 id="新生代对象特点"><a href="#新生代对象特点" class="headerlink" title="新生代对象特点"></a>新生代对象特点</h3><p>大部分情况都是朝生夕死</p>
<h3 id="老年代对象特点"><a href="#老年代对象特点" class="headerlink" title="老年代对象特点"></a>老年代对象特点</h3><p>对象存活率较高，没有额外空间进行分配担保</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体表现。</p>
<h3 id="Serial垃圾收集器"><a href="#Serial垃圾收集器" class="headerlink" title="Serial垃圾收集器"></a>Serial垃圾收集器</h3><p><strong>特点</strong></p>
<ul>
<li>单线程收集</li>
<li>新生代收集器</li>
<li>收集时停止所有工作线程的工作(STOP THE WORLD)</li>
<li>跟其他垃圾收集器相比简单而高效(单个CPU环境下，不存在线程上下文切换的开销，可以获得最高的单线程收集效率)</li>
<li>client模式下新生代默认垃圾收集器</li>
</ul>
<p>Serial收集器是最基本发展最悠久的垃圾收集器，曾经(JDK1.3.1之前)是虚拟机新生代的收集的唯一选择，看名字就可以看出来，这个收集器是一个单线程的收集器，但他的单线程不仅仅体现在它只会使用一个垃圾回收线程去完成垃圾回收工作，更重要的是，在进行垃圾回收的时候必须暂停其他所有的工作线程，直至收集结束。这项工作实际上是虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。</p>
<p><img src="https://pic.yupoo.com/crowhawk/6b90388c/6c281cf0.png" alt><br>Serial/Serial Old垃圾收集器运行示意图</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p><strong>特点</strong></p>
<ul>
<li>新生代收集器</li>
<li>Serial收集器的多线程版本</li>
<li>许多运行在server模式下的虚拟机中首选的新生代收集器</li>
</ul>
<p>ParNew收集器实际上就是Serial收集器的多线程版本，除了使用多条线程进行垃圾手机外，其余的控制参数、垃圾收集算法，Stop The World、对象分配规则、回收策略都跟Serial垃圾收集器完全一样。许多运行在server模式下的虚拟机中首选的新生代收集器，除了Serial外，只有Parnew能配合CMS垃圾收集器工作，单CPU场景下，不会比Serial收集器有更好的效果(存在线程切换的开销)，</p>
<p><img src="https://pic.yupoo.com/crowhawk/605f57b5/75122b84.png" alt><br>ParNew 收集器运行示意图</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p><strong>特点</strong></p>
<ul>
<li>新生代收集器</li>
<li>使用复制算法，多线程收集</li>
<li>关注点与其他收集器不同，关注的是达到一个可控制的吞吐量</li>
</ul>
<p>Parallel Scavenge收集器的特点是他关注的是可控制的吞吐量，即CPU运行用户代码的时间/(CPU运行用户代码时间+ 垃圾收集时间)，举例来说，虚拟机运行100分钟，垃圾收集时间为1分钟，那吞吐量就是99%，该收集器提供了两个参数用于精准控制吞吐量，分别是控制最大垃圾收集时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数</p>
<p>MaxGCPauseMillis 是一个大于0的毫秒数，当然并不是设置的越小越好，GC停顿时间的缩短是以牺牲吞吐量和新生代空间来换取的: 比如把新生代调小，收集300M的新生代肯定比500M要快，这会导致垃圾收集会变得比之前更频繁, 举个例子 原来10秒收集一次，每次停顿100毫秒，现在每5秒收集一次，每次停顿70毫秒，停顿时间是缩小了，但是吞吐量也下来了</p>
<p>吞吐量 = CPU运行用户代码的时间/(CPU运行用户代码时间+ 垃圾收集时间)<br>GCTimeRatio 相当于 1 / 吞吐量</p>
<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial-Old 收集器"></a>Serial-Old 收集器</h3><p><strong>特点</strong></p>
<ul>
<li>老年代收集器</li>
<li>单线程，回收时暂停所有用户线程</li>
<li>使用标记-整理算法</li>
</ul>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p><strong>特点</strong></p>
<ul>
<li>老年代收集器</li>
<li>Parallel Scanvenge的老年代版本，使用多线程</li>
<li>使用标记-整理算法</li>
</ul>
<h3 id="CMS垃圾收集器"><a href="#CMS垃圾收集器" class="headerlink" title="CMS垃圾收集器"></a>CMS垃圾收集器</h3><p><strong>特点</strong></p>
<ul>
<li>老年代收集器</li>
<li>采用标记-清除算法</li>
<li>并发收集，低停顿</li>
<li>CMS MinorGC时会暂停所有的用户线程，并以多线程的方式进行垃圾回收。FullGC时不再暂停应用线程，而是使用若干个后台进程定期的对老年代空间进行扫描，及时回收不再使用的对象</li>
</ul>
<p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的垃圾收集器,很大一部分Java应用集中在互联网网站和B/S系统的服务端上，这类应用重视服务的响应速度，希望系统停顿时间较短，CMS就比较符合这类应用的需求</p>
<h4 id="垃圾收集过程"><a href="#垃圾收集过程" class="headerlink" title="垃圾收集过程"></a>垃圾收集过程</h4><ul>
<li>初始标记 标记GCRoots 能直接关联的对象，速度很快 暂停所有用户线程 </li>
<li>并发标记  进行GCRoots Tracing的过程</li>
<li>重新标记  修正并发标记期间 因用户程序继续工作导致标记产生变动的那一部分对象的标记记录，停顿时间比初始标记时间稍长一些，远比并发标记时间短 暂停所有用户线程</li>
<li>并发清除</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>因为使用标记-清除算法，易产生大量内存碎片，内存碎片较多时，将会给分配大对象带来很大麻烦 可以通过开启FullGC时候进行内存整理，但是会延长停顿时间</li>
<li>CMS收集器无法处理浮动垃圾，可能出现Concurrent Mode Failure而导致另一次的FullGC产生</li>
<li>对CPU资源敏感</li>
</ul>
<p>浮动垃圾: 并发清除阶段，垃圾收集线程和用户线程并行执行，伴随着程序的运行，就会不断有垃圾产生，这些新产生的垃圾在标记过程之后产生，CMS无法在当次垃圾收集进行</p>
<p><img src="https://pic.yupoo.com/crowhawk/fffcf9a2/f60599b2.png" alt><br>CMS收集器运行示意图</p>
<h3 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h3><p>G1的主要关注点在于达到可控的停顿时间，在这个基础上尽可能提高吞吐量，G1被设计用来长期取代CMS垃圾收集器，和CMS的相同点在于都属于并发收集器，大部分收集阶段都不需要挂起应用程序。区别在于G1没有CMS的碎片化问题，同时提供更加可控的停顿时间</p>
<p>G1将整个堆划分为一个个大小相等的小块，每一块的内存是连续的。和分代算法一样，G1中每个块也会充当Eden,Survivor,Old角色，但是他们不是固定的，这使得内存使用更加灵活</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>引入分区概念</li>
<li>合理利用垃圾收集各个周期的资源，解决了CMS及其他收集器的缺陷</li>
<li>使用标记-整理算法</li>
</ul>
<h4 id="对比CMS"><a href="#对比CMS" class="headerlink" title="对比CMS"></a>对比CMS</h4><ul>
<li>不再基于标记-清除算法，不会产生内存碎片</li>
<li>停顿时间可控 G1可以通过设置预期停顿时间来控制垃圾收集时间来避免应用雪崩现象</li>
<li>并行与并发 G1 能够充分的利用CPU，多核环境下的硬件优势来缩短STW的停顿时间</li>
</ul>
<h4 id="垃圾大致收集过程"><a href="#垃圾大致收集过程" class="headerlink" title="垃圾大致收集过程"></a>垃圾大致收集过程</h4><ul>
<li>新生代垃圾收集</li>
<li>并发收集，和用户线程同时执行</li>
<li>混合垃圾收集</li>
<li>必要的时候FullGC</li>
</ul>
<h5 id="G1的堆结构"><a href="#G1的堆结构" class="headerlink" title="G1的堆结构"></a>G1的堆结构</h5><p>传统的GC收集器将内存空间划分为新生代老年代和永久代(JDK1.8去除了永久代，引入了元空间metaspace)，这种划分的特点是各代的存储地址是连续的，而在G1收集器中则引入了分区的概念，弱化了分代的概念。</p>
<ol>
<li>整个堆默认分为2048份均分，每块大小是一致的(1M-32M)</li>
<li>逻辑上，也会分为Eden,Survivor,Old区，但是各个区的大小是不固定的</li>
<li>未分配区域可以为任何一个代使用</li>
</ol>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>服务器多核CPU,JVM所占内存较大的情况(至少大于4G)</li>
<li>应用在运行过程中会产生大量内存碎片，需要经常压缩空间</li>
<li>想要更可控，可预期的GC停顿周期，防止高并发下应用雪崩现象</li>
</ul>
<h2 id="内存分配与垃圾回收策略"><a href="#内存分配与垃圾回收策略" class="headerlink" title="内存分配与垃圾回收策略"></a>内存分配与垃圾回收策略</h2><p>未完待续<del>~</del></p>
<hr>
<h2 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h2><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>《深入理解Java虚拟机》 第2版</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/04/23/about-spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/04/23/about-spring/" itemprop="url">聊聊Spring框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-23T14:05:34+08:00">
                2020-04-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在工作和面试中，Spring作为一个高频出现的框架，不能只是会用，还要对他有一定深入的了解，这样出现问题或者别人跟你交流起Spring的内容的时候，不至于哑口无言，今天我们就来聊聊Spring中我们必须要知道或者掌握的内容</p>
<h1 id="IOC-和AOP"><a href="#IOC-和AOP" class="headerlink" title="IOC 和AOP"></a>IOC 和AOP</h1><p>可以说IOC和AOP是Spring的灵魂，我们无时无刻不在用这两个特性，下面就来讲讲IOC和AOP分别都是什么</p>
<h2 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h2><p>IOC(Inversion of Controll)控制反转，什么是控制反转呢？原来需要开发者手动创建对象，现在这个过程交给Spring容器，Spring预先把对象创建好，你需要的时候声明一个属性直接给注入进来，这样把原来创建对象的控制权给反转过来，就叫控制反转，那在这里我们反转的是什么内容呢？实际上这里我们反转的是获取依赖对象的过程，这样其实IOC其实还有另外一个名字，叫依赖注入，这实际上就是Spring来实现IOC的方式，通过提供一个IOC容器，在容器运行期间，利用依赖关系动态地将某种依赖关系注入到对象中。这样的好处就是最大的程度实现对象之间的解耦合。</p>
<p>比如我有一块业务，分别交给了三个人来实现这一块业务中的三个部分，那么只有这三个人的功能组合到一起才能实现这一块业务，那么每个人都必须要清楚自己的那部分业务什么时候要依赖对方的那一部分的业务，什么时候产生交互，这样沟通成本就很高，每个人都要做一次业务串线的操作，而不是专心于自己的业务，那这个时候，假如我们能引入第4个人，由第4个人来负责怎么样组合起这3个人的业务，什么时候交互，那么这三个人就完全不用处理和其他人之间的业务对接，完全专心于自己那一部分的业务开发了，这其实跟SpringIOC容器的思想就是类似的。</p>
<h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">面向切面的程序设计是计算机科学中的一种程序设计思想，旨在将横切关注点与业务主体进行进一步分离，  </span><br><span class="line">以提高代码模块化的程度。通过在现有代码基础上增加额外的通知机制，能够对被声明为切点(pointcut)  </span><br><span class="line">的代码进行统一的管理和装饰，如对所有‘set*’开头的方法都加上后台日志。该思想能够使得开发人员能够将  </span><br><span class="line">与代码核心业务并不是那么密切相关的功能添加至程序中，同时又不降低业务代码的可读性，面向切面的程序  </span><br><span class="line">设计是面向切面开发的基础   ---摘自WIKIPEDIA</span><br></pre></td></tr></table></figure>

<p>看了维基百科上面的这么长的一段话，想必头都大了，那么到底AOP是什么呢，其实这是一种思想，一种将核心逻辑与边缘逻辑拆分的思想，我们把我们的一块业务进行拆分，把业务强相关的逻辑称为核心逻辑，将不是特别相关的业务逻辑称为边缘逻辑，那么AOP就是把核心逻辑作为关注点，将非核心逻辑也就是边缘逻辑从原有代码剥离出来，形成一个个的切面，在我们的关注点(核心逻辑)前后的连接点插入一系列的切面，将核心逻辑和边缘逻辑通过这种方式编织起来的过程就叫做AOP。这样的好处就是有一些重复的工作像事务管理、日志管理、权限控制等功能封装起来，减少重复代码，并降低模块间的耦合度，有利于系统的拓展性和可维护性。</p>
<h2 id="AOP中的几个重要概念"><a href="#AOP中的几个重要概念" class="headerlink" title="AOP中的几个重要概念"></a>AOP中的几个重要概念</h2><h3 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h3><p>切面的工作被称为通知，通知定义了切面是什么以及何时使用，除了描述切面的工作外，通知还解决了何时执行这个工作</p>
<h3 id="JoinPoint-连接点"><a href="#JoinPoint-连接点" class="headerlink" title="JoinPoint 连接点"></a>JoinPoint 连接点</h3><p>连接点是指应用执行过程中可以插入切面的一个点</p>
<h3 id="PointCut-切点"><a href="#PointCut-切点" class="headerlink" title="PointCut 切点"></a>PointCut 切点</h3><p>一个切面并不需要通知应用所有的连接点，切点有助于缩小切面通知的连接点范围，通知中定义了切面的“什么”和“何时”，而切点则定义了“何处”</p>
<h3 id="Aspect-切面"><a href="#Aspect-切面" class="headerlink" title="Aspect 切面"></a>Aspect 切面</h3><p>切面是通知和切点的集合，通知和切点定义了切面的全部内容，它们是什么，在何时何处完成其功能</p>
<h3 id="Introduction-引入"><a href="#Introduction-引入" class="headerlink" title="Introduction 引入"></a>Introduction 引入</h3><p>Introduction允许我们向现有的类添加新方法和属性</p>
<h3 id="weaving-织入"><a href="#weaving-织入" class="headerlink" title="weaving 织入"></a>weaving 织入</h3><p>织入是将切面应用到目标对象并创建新的代理对象的过程，切面在指定的连接点被织入到目标对象中。在目标对象的生命周期中有很多个点进行织入</p>
<ul>
<li>编译期 切面在目标类编译时被织入。这种方式需要特殊的编译器，AspectJ的织入编译器就是以这种方式织入切面的</li>
<li>类加载期 切面在目标类加载到JVM时候被织入，这种方式需要特殊的类加载器，它可以在目标类被引入到应用程序之前，增强该目标类的字节码。AspectJ 5就支持这种方式织入切面</li>
<li>运行期 切面在应用运行的某个时刻被织入。一般情况下，在织入切面时候AOP容器会为目标对象动态的创建一个代理对象。SpringAOP就是以这种方式织入切面的。</li>
</ul>
<h2 id="Spring-AOP原理"><a href="#Spring-AOP原理" class="headerlink" title="Spring AOP原理"></a>Spring AOP原理</h2><p>Spring是在运行时通知对象，通过在代理类中包裹切面，Spring在运行期间把切面织入到Spring管理的Bean中。如下图所示，代理类封装了目标类，并拦被通知方法的调用，再把调用转发给真正的目标bean.当代理拦截到方法调用的时候，在调用bean方法之前，会执行切面逻辑。</p>
<p>Spring在运行时创建代理对象，代理勒种包裹了切面和目标对象，并拦截被通知方法的调用，在执行bean方法之前或之后执行切面逻辑，之后再将请求转发给目标对象</p>
<p><img src="https://img-blog.csdn.net/20160505123413155" alt><br>图片引用自<a href="https://blog.csdn.net/github_34889651/article/details/51321499" target="_blank" rel="noopener">Spring AOP 之 通知、连接点、切点、切面</a><br>直到应用需要用到被代理的bean时，spring才会创建代理对象，如果是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器就能织入AOP切面</p>
<h1 id="Spring-IOC怎么实现的？"><a href="#Spring-IOC怎么实现的？" class="headerlink" title="Spring IOC怎么实现的？"></a>Spring IOC怎么实现的？</h1><p>IOC实际上是通过在Spring内部持有一个beanfactory 在Spring容器启动的时候将被加上注解的类加载到容器中，当你在使用bean的时候去管Spring的容器拿的一个过程</p>
<h1 id="动态代理和静态代理"><a href="#动态代理和静态代理" class="headerlink" title="动态代理和静态代理"></a>动态代理和静态代理</h1><p>要讲动态代理和静态代理，实际上要先从代理模式说起，什么是代理模式呢？代理模式提供了对目标对象的额外访问方式，即通过代理对象访问目标对象这样可以在不修改目标对象的前提下、提供额外的功能操作，扩展目标对象的功能。说完了什么是代理模式，那么静态代理和动态代理分别是什么呢？其实静态代理还是动态代理是从代理类创建的时间节点来看的，静态代理是在程序运行期前，代理类已经存在了(通过developer由ide编写源代码后，对其编译)，而动态代理是在程序运行期间才会创建相应的代理类，也就是每需要使用静态代理来对目标对象进行增强的时候，就需要创建一个目标对象的代理类，这样就可能带来很多的代理类</p>
<p>静态代理中的角色</p>
<ol>
<li>subject抽象主题类，定义了代理对象和真实对象共同的接口方法，既可以是接口又可以是抽象类</li>
<li>real subject 真实主题类，也就是被委托类或被代理类，该类定义了代理对象表示的真实对象，实现了subject接口，client通过代理对象间接地调用真实主题类中的方法，由real subject来执行真正的业务逻辑</li>
<li>proxy subject 代理类，该类也被称为委托类或代理类，该类中持有一个真实主题类的引用，实现了subject接口，在其实现的接口方法中调用真实主题类中对应的接口方法，起到代理的作用</li>
<li>client 客户端，使用代理</li>
</ol>
<h1 id="spring中bean的生命周期"><a href="#spring中bean的生命周期" class="headerlink" title="spring中bean的生命周期"></a>spring中bean的生命周期</h1><ol>
<li>实例化bean实例及</li>
<li>按照spring上下文对实例化的bean设置对象属性(也就是进行IOC注入)</li>
<li>如果这个bean实现了BeanNameAware接口，会调用它实现的setBeanName方法，此处传递的就是spring配置文件中id的值</li>
<li>BeanPostProcessor前置处理</li>
<li>是否实现InitialBean接口</li>
<li>是否配置自定义的init-method</li>
<li>BeanPostProcessor后置处理</li>
<li>注册</li>
</ol>
<p><img src="https://images0.cnblogs.com/i/580631/201405/181453414212066.png" alt><br><img src="https://images0.cnblogs.com/i/580631/201405/181454040628981.png" alt></p>
<h1 id="Spring的启动流程"><a href="#Spring的启动流程" class="headerlink" title="Spring的启动流程"></a>Spring的启动流程</h1><h2 id="applicationContext继承体系"><a href="#applicationContext继承体系" class="headerlink" title="applicationContext继承体系"></a>applicationContext继承体系</h2><p><img src="https://s1.ax1x.com/2020/04/25/JsJCgH.png" alt></p>
<h2 id="通过SpringApplication-run启动主类"><a href="#通过SpringApplication-run启动主类" class="headerlink" title="通过SpringApplication.run启动主类"></a>通过SpringApplication.run启动主类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动一个计时器,记录应用启动花费的时间()</span></span><br><span class="line">      StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">FailureAnalyzers analyzers = <span class="keyword">null</span>;</span><br><span class="line">configureHeadlessProperty();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">listeners.starting();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">//封装命令行启动应用时的参数</span></span><br><span class="line">	ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">			args);</span><br><span class="line">	<span class="comment">//1.准备应用运行时环境，</span></span><br><span class="line">	<span class="comment">//2.加载外部配置文件(发布ApplicationEnvironmentPreparedEvent，SpringApplicationRunListeners监听到后，分发给下面的listeners,ConfigFileApplicationListener收到事件后去各个目录扫配置文件(xml,yaml,properties))</span></span><br><span class="line">	<span class="comment">//3.发布ApplicationEnvironmentPreparedEvent </span></span><br><span class="line">	ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">			applicationArguments);</span><br><span class="line">	<span class="comment">//打印启动banner图</span></span><br><span class="line">	Banner printedBanner = printBanner(environment);</span><br><span class="line">	<span class="comment">//创建ConfigurableEnvironment的实例(反射)，即创建IOC容器</span></span><br><span class="line">	context = createApplicationContext();</span><br><span class="line">	analyzers = <span class="keyword">new</span> FailureAnalyzers(context);</span><br><span class="line">	<span class="comment">//容器刷新前调用，允许对容器做进一步的设置和处理</span></span><br><span class="line">	prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">			printedBanner);</span><br><span class="line">	refreshContext(context);</span><br><span class="line">	afterRefresh(context, applicationArguments);</span><br><span class="line">	<span class="comment">//容器启动完成，通知关注的listeners(发布ApplicationReadyEvent)</span></span><br><span class="line">	listeners.finished(context, <span class="keyword">null</span>);</span><br><span class="line">	<span class="comment">//计时器停止计时，打印启动所花费的时间</span></span><br><span class="line">	stopWatch.stop();</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">		<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">				.logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">	handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="refreshContext"><a href="#refreshContext" class="headerlink" title="refreshContext"></a>refreshContext</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置启动时间，启动标志，移除所有类元数据缓存，准备刷新时的应用上下文</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"><span class="comment">//告子类刷新内部beanFactory</span></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line"><span class="comment">//准备在此上下文中使用的beanfatory(设置classloader和postProcessors,注册环境以及系统变量bean)</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">	postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">	invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">	<span class="comment">//注册bean后置处理器</span></span><br><span class="line">	registerBeanPostProcessors(beanFactory);</span><br><span class="line">	<span class="comment">//做国际化处理i18n</span></span><br><span class="line">	<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">	initMessageSource();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">	initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">	onRefresh();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">	registerListeners();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">	<span class="comment">//初始化剩余的所有单例bean</span></span><br><span class="line">	finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">	<span class="comment">//完成容器初始化，发布容器刷新完成事件</span></span><br><span class="line">	finishRefresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Spring和SpringBoot的区别"><a href="#Spring和SpringBoot的区别" class="headerlink" title="Spring和SpringBoot的区别"></a>Spring和SpringBoot的区别</h1><ul>
<li>SpringBoot内嵌了tomcat容器，不用再使用独立的web容器</li>
<li>SpringBoot相对于Spring来说，使用约定由于配置的原则，不在通过以前那种大量的xml配置和引入一大堆依赖，大大简化了开发人员的工作</li>
<li>可以实现自动装配</li>
</ul>
<h1 id="Spring-Cloud中用过哪些组件"><a href="#Spring-Cloud中用过哪些组件" class="headerlink" title="Spring Cloud中用过哪些组件"></a>Spring Cloud中用过哪些组件</h1><p>注册中心  配置中心  网关 </p>
<h1 id="eureka、zookeeper做注册中心有什么区别"><a href="#eureka、zookeeper做注册中心有什么区别" class="headerlink" title="eureka、zookeeper做注册中心有什么区别"></a>eureka、zookeeper做注册中心有什么区别</h1><h1 id="feign是如何保证负载均衡和熔断策略的"><a href="#feign是如何保证负载均衡和熔断策略的" class="headerlink" title="feign是如何保证负载均衡和熔断策略的"></a>feign是如何保证负载均衡和熔断策略的</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/04/20/about-cache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/04/20/about-cache/" itemprop="url">谈谈缓存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-20T12:08:54+08:00">
                2020-04-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前文章提到过，redis的常见使用场景之一就是缓存，那么既然聊到缓存，那么肯定会聊到缓存和数据库双写一致性的问题，今天就来聊聊缓存跟数据库双写一致性的问题</p>
<h1 id="缓存双写一致性问题"><a href="#缓存双写一致性问题" class="headerlink" title="缓存双写一致性问题"></a>缓存双写一致性问题</h1><p>只要系统用缓存，就可能涉及到缓存和数据库双写，只要设计到双写，就可能存在一致性问题</p>
<h2 id="缓存更新的策略"><a href="#缓存更新的策略" class="headerlink" title="缓存更新的策略"></a>缓存更新的策略</h2><h3 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h3><h4 id="为什么是删除缓存而不是更新缓存？"><a href="#为什么是删除缓存而不是更新缓存？" class="headerlink" title="为什么是删除缓存而不是更新缓存？"></a>为什么是删除缓存而不是更新缓存？</h4><ul>
<li><p><strong>缓存更新的代价可能比较高，数据更新如果不是热点数据存在资源浪费</strong><br>写多读少的场景，缓存根本没有被读到，反而进行了大量的更新，浪费性能<br>写入数据库的值不是直接写入缓存，而是还需要进行一些计算，每次写完数据库再进行一些计算，浪费性能，相比之下，删除缓存反而比较适合</p>
</li>
<li><p>存在脏数据问题,并发更新缓存<br>A,B同时更新一条缓存，B先更新完的，A再执行就把B更新过来的数据给覆盖掉了</p>
</li>
</ul>
<p>再回到先删除缓存再更新数据库这里，也存在数据不一致的情况</p>
<p>场景：请求A进行更新操作，请求B进行查询操作</p>
<p>1） 请求A进行写操作，删除缓存<br>2）请求B进行读操作,查询缓存发现缓存不存在<br>3）请求B查询数据库，将数据库中的旧值<br>4）请求B将旧值写入缓存<br>5) 请求A将新值写入数据库</p>
<p>如果不设置过期时间，请求B写入的脏数据就会一直存在，这种问题如何解决呢？<br>可以通过延时双删策略,如下述所示</p>
<p>1）删除缓存<br>2）更新数据库<br>3）延时等待(等待刚才的读请求完成操作)<br>4）再次删除缓存</p>
<p>这个延时的时间需要自行评估自己项目中读请求B的操作时间，并在读请求B的耗时上+几百毫秒来确保读请求结束</p>
<p>这种延时会降低吞吐量，怎么办？<br>将第二次删除改为异步删除，写请求更新完数据库直接返回，不必再延时等待了</p>
<p>如果第二次删除失败了，怎么办？</p>
<p>提供保障机制:删除重试策略</p>
<h3 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title="先更新数据库，再删除缓存"></a>先更新数据库，再删除缓存</h3><p>这种方案又名为《cache-aside pattern》</p>
<ul>
<li>读的时候，先读缓存，缓存中如果没有再读数据库，然后取出后放入缓存，同时返回响应</li>
<li>更新的时候，先更新数据库，再删除缓存</li>
</ul>
<p>这里实际上是应用了一种懒加载的思路，什么时候用，什么时候再去计算缓存</p>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>有可能存在脏数据问题</p>
<ul>
<li>并发读写</li>
</ul>
<ol>
<li>缓存刚好失效</li>
<li>请求A过来查询缓存，发现没有查询数据库得到一个旧值</li>
<li>请求B更新数据库</li>
<li>请求B删除缓存</li>
<li>请求A将查到的旧值更新到缓存中</li>
</ol>
<p>这种情况要求3中写操作比2中读操作要快，才有可能导致4比5要快，但是一般来说数据库读的远快于数据库的写操作，因此这一情形比较难出现，但不是不会出现，那么如果出现了这种问题要如何解决呢？</p>
<ul>
<li>设置缓存的有效期</li>
<li>在请求B更新完数据库后，采用异步延时删除的策略，并确保此时没有操作这一缓存的读请求后再删除缓存</li>
</ul>
<hr>
<ul>
<li>删除缓存失败导致脏数据</li>
</ul>
<p>一个写操作将新值写入数据库，然后删除缓存时失败，(无论先删缓存还是后删缓存都会存在这个问题)导致缓存数据库数据不一致</p>
<p>解决方案: 提供一个保障重试的机制即可，确保最终缓存被清除</p>
<h1 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a>缓存雪崩问题</h1><p> 简介
Redis服务重启或者宕机，或者大量缓存在同一时刻失效，此时大量的请求全部打到DB上，DB有可能扛不住从而导致宕机
</p>

<p>解决方案: </p>
<ul>
<li>给每个缓存设置不同的失效时间(比如用当前时间+随机时间段)，避免大量缓存在同一时间失效</li>
<li>如果是集群部署，将热点数据均匀分布在不同的redis节点上也能避免全部失效的问题，或者热点数据压根就不设置过期时间</li>
</ul>
<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>简介
要查询的数据在缓存和数据库内都不存在，用户不断用这样的数据发起请求，导致数据库压力激增，严重时候可能拖垮数据库
</p>

<p>解决方案: </p>
<ol>
<li>接口层增加校验，用户添加鉴权，接口参数做校验，不合法参数直接返回，缓存和数据库中都取不到的数据，也可以将对应的key value(置为null)缓存起来，过期时间设置短一点，这样可以保证同一个用户无法反复用一个数据暴力攻击</li>
<li>可以使用布隆过滤器</li>
</ol>
<h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p>
缓存击穿其实跟缓存雪崩有点类似，只不过缓存击穿是指单个key值非常热点，在不停的接收并发，当这个key失效的瞬间持续的并发将缓存击穿，流量直接打到DB上面
</p>

<p>解决方案:</p>
<ul>
<li>设置热点数据永不过期</li>
<li>查缓存时候没有拿到去数据库查询，更新缓存的这一步加上互斥锁，拿不到的读请求需要进行一个自旋，等一会儿再去拿数据，拿到互斥锁的请求将数据更新到缓存后，后续的请求全都自旋完毕后直接从缓存中拿数据了，相当于给缓存“续了个费”</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.cnblogs.com/rjzheng/p/9041659.html" target="_blank" rel="noopener">分布式之数据库和缓存双写一致性方案解析</a><br><a href="https://juejin.im/post/5dbef8306fb9a0203f6fa3e2" target="_blank" rel="noopener">《我们一起进大厂》系列-缓存雪崩、击穿、穿透</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/04/20/about-redis-durability/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/04/20/about-redis-durability/" itemprop="url">谈谈redis中的持久化机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-20T12:07:33+08:00">
                2020-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="为什么要进行持久化"><a href="#为什么要进行持久化" class="headerlink" title="为什么要进行持久化"></a>为什么要进行持久化</h1><p>为了避免数据丢失</p>
<p>
redis作为一个键值对的内存数据库，数据全存储在内存当中，当遇到进程退出或者服务器重启宕机的情况，内存中的数据就会消失，那这样存在redis中的数据就全丢了，如果业务场景仅仅是缓存，数据丢失影响或许不大，重新去数据库加载下再次写入redis就行了，但是如果把业务数据存储在redis中，拿redis当数据库使用的话，数据的丢失可能是毁灭性的打击，所以为了避免数据丢失，redis提供了持久化的支持，可以选择不同的方式将数据从内存保存到磁盘上面，使数据可以持久化保存。
</p>

<h1 id="redis持久化机制"><a href="#redis持久化机制" class="headerlink" title="redis持久化机制"></a>redis持久化机制</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB 是一种快照存储持久化方式，持久化的时候fork一个子进程，通过COW机制生成RDB文件保证持久化</p>
<p>具体就是将某一时刻的内存数据保存为一个快照存储到磁盘中，默认文件名为dump.rdb,在redis服务启动的时候会将dump.rdb文件加载到内存中恢复数据。</p>
<h3 id="RDB触发条件"><a href="#RDB触发条件" class="headerlink" title="RDB触发条件"></a>RDB触发条件</h3><h4 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h4><p>通过在redis服务上面执行以下命令触发</p>
<ul>
<li>save 阻塞当前redis服务，执行save期间，redis服务不能处理其他命令，直到RDB过程完成为止，线上环境不建议使用</li>
<li>bgsave 执行该命令时，redis会在后台异步进行快照操作，此时redis服务仍然可以响应客户端请求。<br>具体操作是执行该命令时，redis会执行fork操作创建一个子进程，由子进程来负责RDB持久化过程，完成后自动结束。这里需要注意的是在fork的时候需要阻塞主进程，一般时间比较短，但是如果redis服务中的数据量比较大的话，fork时间就会变长，且占用内存会加倍。</li>
</ul>
<h4 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h4><p>自动触发是通过redis.conf配置自动触发 通过save “”来停用自动触发RDB</p>
<p>主从同步时，从节点向主节点发起同步请求，主节点收到sync命令后，开始执行bgsave</p>
<p>etc: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save 60 1 60s内如果 &gt;= 1个key值发生变化则会触发RDB</span><br><span class="line">save 600 10 600s内如果 &gt;= 10个key值发生变化会触发RDB</span><br></pre></td></tr></table></figure>

<h3 id="bgsave流程"><a href="#bgsave流程" class="headerlink" title="bgsave流程"></a>bgsave流程</h3><ol>
<li>查看是否正在进行RDB或者AOF持久化，是则直接返回</li>
<li>当前不在进行持久化，fork子进程，子进程和父进程共享内存数据，父进程发生新的写入操作时，会对影响的数据拷贝一个新的内存段(<strong>存在疑问</strong>)，在新的内存段上面进行处理，不影响子进程的数据</li>
<li>子进程将数据集写入到一个临时的RDB文件中</li>
<li>子进程对临时RDB文件写入完成后，用新的RDB文件替换老的RDB文件，并删除旧的RDB文件，并通过信号通知父进程</li>
</ol>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>AOF(Append Only File)是指把每次执行的写命令追加写入到日志中，当需要恢复数据的时候重新执行AOF中的命令就行了。实际上redis每次写入并没有直接写入到日志文件里，而是写入到一个缓冲区(aof_buf)中，而后通过缓冲区同步策略对缓冲区的数据进行落盘操作</p>
<h3 id="AOF执行流程"><a href="#AOF执行流程" class="headerlink" title="AOF执行流程"></a>AOF执行流程</h3><p>AOF不需要设置任何触发条件，对redis服务的所有写命令都会记录到AOF文件中</p>
<p>AOF的写入流程可以分为以下3个步骤</p>
<ol>
<li>命令追加(append): 将redis的写命令追加到AOF的缓冲区aof_buf</li>
<li>文件写入(write)和文件同步(fsync):AOF根据策略将aof_buf中的数据同步到磁盘</li>
<li>文件重写(rewrite):由于AOF文件会越来越大，定期对AOF文件进行重写，从而对写命令进行压缩</li>
</ol>
<h4 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h4><p>redis使用单线程处理客户端命令，如果每次一有写命令就写磁盘的话，磁盘IO就成为redis的性能瓶颈了，所以redis会预先将执行的写命令追加(append)到一个缓冲区(aof_buf)，而不是直接写入文件</p>
<h4 id="文件写入和文件同步"><a href="#文件写入和文件同步" class="headerlink" title="文件写入和文件同步"></a>文件写入和文件同步</h4><ol>
<li>write()<br>为了提高文件写入效率，当用户调用write函数将数据写入文件时，操作系统会先把数据写入到一个内存缓冲区中，当缓冲区被填满或者超过了指定时限时，才真正将缓冲区的数据写入磁盘中</li>
<li>fsync()<br>虽然操作系统对write函数进行了优化，但是也带来了安全问题，如果宕机内存缓冲区中的数据会丢失，因此操作系统同时提供了同步函数fsync(),强制操作系统把缓冲区内部的数据写入到磁盘中，从而保证了数据持久化</li>
</ol>
<p>redis提供了appendfsync配置项来控制AOF缓冲区的文件同步策略，可以配置以下三种策略</p>
<ul>
<li>appendfsync always: 每执行一次命令就保存一次</li>
</ul>
<p>命令写入aof_buf后立即调用系统函数fsync函数同步到aof文件，fsync操作完成后线程返回，整个过程是阻塞的，这种情况下，每次写命令都要同步到AOF文件，硬盘IO成为性能瓶颈,redis只能支持大约几百TPS写入，严重降低了redis的性能</p>
<ul>
<li><p>appendfsync no: 不强制保存，由操作系统决定什么时候写入磁盘<br>命令写入aof_buf中缓冲区调用系统write操作，不对AOF文件做fsync操作，同步由操作系统负责，通常同步周期为30秒，这种情况下、文件同步时间不可控制，且缓冲区内的数据会很多，数据安全性无法得到保证</p>
</li>
<li><p>appendfsync everysec: 每秒钟保存一次<br>命令写入aof_buf缓冲区后，调用系统write操作，write完成后立即返回，fsync同步操作由单独的进程每秒调用一次，everysec是前两种策略的折中方案，是性能和数据安全性的平衡，因此也是redis的默认设置，也是比较推崇的选项</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>文件同步策略</th>
<th>write 阻塞</th>
<th>fsync阻塞</th>
<th>宕机时丢失的数据量</th>
</tr>
</thead>
<tbody><tr>
<td>always</td>
<td>阻塞</td>
<td>阻塞</td>
<td>最多只丢失一个命令的数据量</td>
</tr>
<tr>
<td>no</td>
<td>阻塞</td>
<td>不阻塞</td>
<td>操作系统最后一次对AOF文件fsync后的数据</td>
</tr>
<tr>
<td>everysec</td>
<td>阻塞</td>
<td>不阻塞</td>
<td>一般不超过一秒的数据</td>
</tr>
</tbody></table>
<h4 id="文件重写"><a href="#文件重写" class="headerlink" title="文件重写"></a>文件重写</h4><p>AOF重写过程提供了手动触发和自动触发两种方式</p>
<ul>
<li>手动触发: 直接调用bgrewriteaof,执行方式类似于bgsave，fork子进程执行具体的操作，fork时阻塞</li>
<li>自动触发: 使用auto-aof-rewrite-min-size和auto-aof-rewrite-percentage配置项以及aof_current_size和aof_base_size的状态确定触发时机<ul>
<li>auto-aof-rewrite-min-size: 执行AOF重写时,文件的最小体积，默认64M</li>
<li>auto-aof-rewrite-percentage: 执行AOF重写时，当前AOF文件的大小(aof_current_size)和上一次AOF重写时AOF文件大小(aof_base_size)的比值</li>
</ul>
</li>
</ul>
<h4 id="文件重写流程"><a href="#文件重写流程" class="headerlink" title="文件重写流程"></a>文件重写流程</h4><p>这里以手动调用bgrewriteaof为例，叙述下AOF重写的流程</p>
<ol>
<li><p>客户端通过bgrewriteaof对redis主进程发起AOF重写请求</p>
</li>
<li><p>当前不存在bgsave/bgrewriteaof的子进程时，redis主进程fork子进程(阻塞)，如果发现bgrewriteaof子进程则直接返回，如果发现bgsave子进程则等待bgsave操作完成后再fork操作</p>
</li>
<li><p>主进程fork操作执行完毕后，继续处理其他命令，同时把新的写命令追加到aof_buf中和aof_rewrite_buf缓冲区中</p>
<ul>
<li>文件重写完成之前，主进程会继续把写命令追加到aof_buf缓冲区，根据appendfsync策略将写命令同步到老的AOF文件内，这样可以避免AOF重写失败造成数据丢失，保证原有AOF文件的正确性</li>
<li>由于fork操作时运用写时复制技术，子进程共享fork操作时的内存数据，主进程会把新命令追加到一个aof_rewrite_buf缓冲区中，避免AOF重写失败造成数据丢失这部分数据</li>
</ul>
</li>
<li><p>子进程读取redis进程中的数据快照，生成写入命令后按照命令合并规则批量写入到新的AOF文件</p>
</li>
<li><p>子进程写完新的AOF文件后，向主进程发信号，主进程更新统计信息，具体可以通过info persistence指令查看</p>
</li>
<li><p>主进程接收到子进程的写入完成信号后，将aof_rewrite_buf缓冲区的写命令追加到新的AOF文件</p>
</li>
<li><p>主进程使用新的AOF文件替换旧的AOF文件，AOF重写完成</p>
</li>
</ol>
<h3 id="压缩机制"><a href="#压缩机制" class="headerlink" title="压缩机制"></a>压缩机制</h3><p>文件重写之所以能够压缩AOF文件的大小，主要在于以下原因</p>
<ul>
<li>过期的数据不再写入AOF文件</li>
<li>无效的命令不再写入AOF文件(比如重复的key值设置，set key1 v1 set key1 v2,已经删除的数据)</li>
<li>多条命令可以合并为单个 sadd testset v1 sadd testset v2 sadd testset v3可以合并为 sadd testset v1 v2 v3</li>
</ul>
<h2 id="RDB、AOF对比"><a href="#RDB、AOF对比" class="headerlink" title="RDB、AOF对比"></a>RDB、AOF对比</h2><p>RDB优点</p>
<ul>
<li>与AOF相比，通过rdb文件恢复数据比较快</li>
<li>rdb十分紧凑，适合用来做数据备份</li>
<li>通过RDB进行数据备份，由于使用子进程生成，所以对redis服务器性能影响较小</li>
</ul>
<p>缺点</p>
<ul>
<li>如果服务器宕机的话，使用RDB方式会造成某个时间段内的数据丢失，比如设置10分钟同步一次，或者5分钟写入1000次就同步一次，如果在这个过程中服务器宕机，则这个时间段的数据就会丢失</li>
<li>使用save方式会造成服务器阻塞，同步完成后才能响应后续请求</li>
<li>使用bgsave命令的时候，如果内存中的数据太大，fork也会发生阻塞，另外fork子进程会耗费内存</li>
<li>redis子进程向磁盘写入数据会带来IO压力</li>
</ul>
<p>AOF优点：</p>
<ul>
<li>AOF只是追加日志文件，对服务器性能影响较小，速度比RDB要快，消耗的内存较少<br>AOF的缺点:</li>
<li>AOF生成的日志太大，即使有重写操作，文件体积仍然很大</li>
<li>恢复数据的速度比RDB要慢很多</li>
<li>AOF文件重写也是通过fork子进程的方式处理的，存在fork时阻塞问题</li>
</ul>
<h2 id="RDB还是AOF，如何去选择？"><a href="#RDB还是AOF，如何去选择？" class="headerlink" title="RDB还是AOF，如何去选择？"></a>RDB还是AOF，如何去选择？</h2><p>其实策略的选择主要是看业务中对数据丢失的容忍度，如果可以接受十几分钟或者更多的数据丢失，那么就可以选择RDB,性能更好，如果只能接受秒级别的数据丢失，选择AOF方案更为合适</p>
<h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><p>为什么这里会牵扯到主从复制原理呢？因为主从复制的内容实际上部分内容就是通过RDB来实现的，所以我们在这篇文章一同就给处理了，下面就来讲解下主从复制的原理</p>
<h3 id="如何开启主从复制"><a href="#如何开启主从复制" class="headerlink" title="如何开启主从复制"></a>如何开启主从复制</h3><ul>
<li>redis服务启动后，执行slaveof <masterip> <masterport>命令</masterport></masterip></li>
<li>配置文件配置 slaveof <masterip> <masterport></masterport></masterip></li>
<li>启动命令后面加 –slaveof <masterip> <masterport></masterport></masterip></li>
</ul>
<p>主从复制的开启完全是在从节点发起的，不需要主节点做任何事情</p>
<h3 id="保存主节点信息"><a href="#保存主节点信息" class="headerlink" title="保存主节点信息"></a>保存主节点信息</h3><p>保存主节点信息 从节点服务器内部维护了masterhost和masterport两个字段用于存储主节点ip和端口<br>一般redis节点通过slaveof host port命令来将当前redis服务器变为指定服务器的从属服务器，从而使得从服务器对该主服务器进行复制(实际的复制操作在slaveof命令执行后并返回OK之后才开始进行)</p>
<h3 id="建立socket连接"><a href="#建立socket连接" class="headerlink" title="建立socket连接"></a>建立socket连接</h3><p>从节点每秒1次调用复制定时函数replicationCron(),如果发现有主节点可以连接，便会根据主节点的ip和port，创建socket连接，如果连接成功，则：<br>从节点： 为该socket建立一个专门处理复制工作的文件事件处理器，负责后续复制工作，收接收RDB文件，接收命令传播</p>
<p>主节点:接收到从节点的socket连接后，并将从节点当作是连接到主节点的一个客户端，后续的命令会以从节点向主节点发送命令请求的形式来进行</p>
<h3 id="发送ping命令"><a href="#发送ping命令" class="headerlink" title="发送ping命令"></a>发送ping命令</h3><p>从节点向主节点发送ping命令,主要有以下作用</p>
<ul>
<li>检测主从之间套接字是否可用</li>
<li>检测主节点是否可以接收处理命令</li>
</ul>
<p>可能有以下三种情况</p>
<ul>
<li>主节点返回pong,socket 正常，主节点可以处理请求，复制过程继续</li>
<li>超时，一定时间内仍未收到主节点的回复，说明socket连接不可用，从节点断开socket连接并重连</li>
<li>返回pong以外的结果，如果主节点返回其他结果，如果处理正在超时运行的脚本，说明主节点当前无法处理命令，断开socket连接并重连</li>
</ul>
<h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><p>如果从节点设置了masterauth选项，则从节点需要进行身份验证，没有配置则跳过<br>身份验证是通过从节点向主节点发送auth命令进行的，auth的参数为配置文件中masterauth的值，如果从节点masterauth和主节点requirepass状态一致，则身份验证通过，复制过程继续，不一致，则断开socket连接，并重连</p>
<h3 id="发送从节点端口信息"><a href="#发送从节点端口信息" class="headerlink" title="发送从节点端口信息"></a>发送从节点端口信息</h3><p>身份验证通过后，从节点会向主节点发送其监听的端口号,主节点将信息保存到该从节点对应的客户端的slave_listen_port中，这个端口信息是用来在主节点查询主从复制状态的时候显示的端口信息，没什么别的作用(info replication)</p>
<h3 id="同步数据"><a href="#同步数据" class="headerlink" title="同步数据"></a>同步数据</h3><p>主从节点的连接建立后，便可以开始数据同步</p>
<ul>
<li>从节点第一次/重新连接主节点，发起数据同步指令(2.8之前是SYNC,2.8之后是PSYNC)</li>
<li>主节点接收到同步指令后，根据主从节点状态的不同，可以分为全量复制和部分复制<h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h4>用于初次复制或者其他无法进行部分复制的情况，将主节点的所有数据发送给从节点，是一个非常重型的操作</li>
</ul>
<p><strong>全量复制过程</strong></p>
<ul>
<li>从节点判断无法进行部分复制，向主节点发送全量复制请求(或从节点发送部分复制请求，主节点判断无法进行部分复制)</li>
<li>主节点接收到全量复制的指令后，执行bgsave,    在后台生成RDB文件，并用一个缓冲区记录记录从生成快照的时间节点后开始执行的写命令</li>
<li>主节点bgsave执行完毕后，将RDB文件发送给从节点，从节点首先清除自己的旧数据，然后载入收到的RDB文件，将状态更新至主节点执行bgsave时候的状态</li>
<li>主节点将缓冲区中的所有写命令发给从节点，从节点执行这些命令，从节点更新至主节点最新状态</li>
</ul>
<p>通过全量复制的过程，可以发现全量复制是非常重型的操作</p>
<ul>
<li>主节点通过bgsave fork子进程进行RDB持久化，该过程非常耗费CPU，内存，硬盘IO</li>
<li>主节点通过网络节点将RDB文件发送给从节点，对主从节点的带宽消耗很大</li>
<li>从节点清空老数据、载入RDB文件的过程是阻塞的，无法响应客户端的命令</li>
</ul>
<h4 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h4><p>用于网络中断后等情况的复制，只将中断期间主节点执行的写命令发送给从节点，比全量复制更加高效，但是如果网络中断时间过长，主节点没有能够完整地保存中断期间的写命令，仍然无法用部分复制还是使用全量复制</p>
<p>由于全量复制在主节点数据量较大的时候效率太低，redis从2.8开始提供部分复制，部分复制的实现依赖于三个重要的概念：</p>
<h5 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h5><p>主节点和从节点分别维护了一份复制偏移量(offset),代表的是主节点向从节点传递的字节数，主节点每次向从节点传播N个字节数据时，主节点offset增加N,从节点每次收到主节点N字节的数据时，从节点的offset增加N<br>offset用于判断主从节点状态是否不一致，二者offset相同，则一致，二者offset不一致，可以根据offset找出从节点缺少的那部分数据，比如主节点offset是1000，从节点offset是500，则需要把主节点501-1000的数据传递给从节点</p>
<h5 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h5><p>主节点维护的、固定长度的、先进先出的队列，默认大小1MB,当主节点开始有从节点时创建，其作用是备份主节点最近发给从节点的数据，无论有几个从节点，复制积压缓冲区都只有一个，命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区，作为写命令的备份，复制积压缓冲区还存储了每个字节对应的复制偏移量，由于复制缓冲区定长且先进先出，所以它保存的是主节点最近执行的写命令，时间较早的会被挤出缓冲区</p>
<p>从节点将offset发送给主节点后，主节点根据offset和缓冲区大小判断能否进行部分复制</p>
<ul>
<li>如果从节点offset偏移量之后的数据，还在主节点复制缓冲区里面，则执行部分复制</li>
<li>如果从节点offset偏移量之后的数据，已不在复制积压缓冲区内，则执行全量复制</li>
</ul>
<h5 id="服务器运行ID-runid"><a href="#服务器运行ID-runid" class="headerlink" title="服务器运行ID(runid)"></a>服务器运行ID(runid)</h5><p>每个redis节点(主从均适用)都有一个runid(启动时随机生成的，每次启动都不一样),主节点初次复制的时候，主节点将自己的runid发送给从节点,从节点保存起来，断线重连后从节点将保存的runid发送给主节点，主节点根据runid判断是否能够进行部分复制</p>
<ul>
<li>如果从节点传过来的runid和和主节点现在的runid相同，证明之前跟主节点同步过，尝试进行部分复制(具体能不能复制还要看offset和复制积压缓冲区情况)</li>
<li>如果传过来的runid和主节点现在的runid不同，说明断线前同步的节点不是当前主节点，只能进行全量复制</li>
</ul>
<h5 id="psync命令的执行"><a href="#psync命令的执行" class="headerlink" title="psync命令的执行"></a>psync命令的执行</h5><p><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180628011547892-692403928.png" alt><br>图片来源《redis设计与实现》</p>
<h3 id="命令传播阶段"><a href="#命令传播阶段" class="headerlink" title="命令传播阶段"></a>命令传播阶段</h3><p>数据同步完成后，主节点进入命令传播阶段，主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保持主从节点的数据一致性</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://juejin.im/post/5da14c37e51d45784603adb7#heading-17" target="_blank" rel="noopener">一文深度揭秘Redis的磁盘持久化机制</a></p>
<p><a href="https://blog.csdn.net/Stubborn_Cow/article/details/50442950" target="_blank" rel="noopener">Redis 主从复制 原理与用法</a></p>
<p><a href="http://redisdoc.com/replication/slaveof.html" target="_blank" rel="noopener">redis命令参考#slaveof</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/04/17/how-to-guarantee-message-sending-reliably-with-rabbitmq/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/04/17/how-to-guarantee-message-sending-reliably-with-rabbitmq/" itemprop="url">谈谈rabbitmq中如何保证消息的可靠传输</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-17T21:56:46+08:00">
                2020-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/rabbitmq/" itemprop="url" rel="index">
                    <span itemprop="name">rabbitmq</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们经常会在项目里面有用到消息队列的场景，比如贷款场景，用户之前在我们这里借了一笔钱，今天把钱还清了，假设这个时候需要发送一个含有推广链接的短信，或者这个用户还钱的时候正好触发了某个规则，可以对这个用户进行额度提升的操作，都可以用消息队列来处理，那么问题来了，</p>
<ol>
<li>消息是如何投递的？</li>
<li>消息是否成功的投递到了消息队列中？</li>
<li>消息投递过程中是否会有丢失的问题？消息是否被正确消费了呢？<br>带着上述的几个问题并以rabbitmq为例开始我们今天的主题</li>
</ol>
<h1 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h1><p>在计算机网络中，一个可靠的通讯协议可以通知发送者它发送的数据是否成功到达消息接收方，那么在rabbitmq中消息是怎样投递的呢？</p>
<h1 id="rabbitmq-消息投递过程"><a href="#rabbitmq-消息投递过程" class="headerlink" title="rabbitmq 消息投递过程"></a>rabbitmq 消息投递过程</h1><ul>
<li>生产者生产消息</li>
<li>生产者建立与broker的连接</li>
<li>生产者发送消息到broker</li>
<li>broker收到消息，并通过消息中的exchange，routing-key将其路由到指定队列</li>
<li>consumer监听到指定队列的消息并消费</li>
</ul>
<p>那么这里我们可以提出几个问题</p>
<h2 id="生产者是否成功地将消息投递到broker"><a href="#生产者是否成功地将消息投递到broker" class="headerlink" title="生产者是否成功地将消息投递到broker?"></a>生产者是否成功地将消息投递到broker?</h2><p>在默认情况下，rabbitmq 生产者发送完消息后，是不会给rabbitmq返回任何结果的，那很有可能消息发送到一半因为网络或其他原因，消息没有到达broker，消息直接丢失，这种情况是我们无法忍受的，当然rabbitmq也提供了两种方式解决这种问题，供我们自行选择。</p>
<ul>
<li>事务消息模式</li>
<li>发送方确认模式</li>
</ul>
<h2 id="生产者的消息到达broker后，在broker中是否会丢失？"><a href="#生产者的消息到达broker后，在broker中是否会丢失？" class="headerlink" title="生产者的消息到达broker后，在broker中是否会丢失？"></a>生产者的消息到达broker后，在broker中是否会丢失？</h2><p>消息到达broker后，很有可能因为一些原因导致broker重启或者退出，因为rabbitmq的消息默认都是在内存里面的，发生重启会导致消息丢失，这也是我们无法忍受的，这里用到了rabbitmq中的持久化机制，需要我们同时保证3个条件，才能保证消息的持久化</p>
<ul>
<li>消息投递时开启了持久化</li>
<li>目标交换机开启了持久化</li>
<li>目标队列开启了持久化</li>
</ul>
<ul>
<li>消息是否被消费者成功消费呢？</li>
</ul>
<p>正常来讲如果消息投递成功了，并且在broker开启了持久化是不是就能保证消息可靠传输了呢？答案是否定的，消费者消费也可能出现问题，比如消费失败，或者消息压根就没有到达消费者(丢了)，这个时候又该如何处理呢？RabbitMQ这里提供了一个消费确认的机制，这种机制分为手动确认和自动确认</p>
<ul>
<li>manual ack 需要业务方根据消费情况手动确认消息消费情况</li>
<li>auto ack 消息一经broker发出，就认为已经投递成功了</li>
</ul>
<p>很显然 autoack这种是有消息丢失风险的，我们很难保证业务方正确消费的情况，所以一般来说我们想要保证消费的可靠性需要开启手动ack模式，确保业务方正确消费后，再进行确认，下面就说一下手动确认在标准AMQP协议中定义的手动ack的接口方法</p>
<ul>
<li><p>basic.ack 如果业务方正确消费了消息，那么业务方需要给broker发送一个ack消息，代表消息已经正确处理, broker可以将这条消息删除了</p>
</li>
<li><p>basic.reject 如果业务方发生了异常或者因为某些原因导致无法消费消息，可以给broker发送拒绝消息，让这条消息重新入队，以便让别的消费者可以消费这条消息   对应标准AMQP0.9.1.1协议中的 basic.reject方法</p>
</li>
<li><p>basic.nack  在basic.reject的基础上提供批量拒绝消息的方法</p>
</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.rabbitmq.com/confirms.html" target="_blank" rel="noopener">rabbitmq官网#Consumer Acknowledgements and Publisher Confirms</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/04/16/how-to-guarantee-redis-high-availability/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/04/16/how-to-guarantee-redis-high-availability/" itemprop="url">谈谈如何保障redis的高可用?</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-16T20:02:54+08:00">
                2020-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>
我们都知道，系统中每引入一个新的中间件，都会造成可用性的降低，举个例子，本来我只需要保障应用本身高可用即可，现在又引入了中间件A，如果它宕机了怎么办？所以，伴随着这个话题，我们今天就来聊聊如果保证redis的高可用

</p>

<h1 id="高可用方案"><a href="#高可用方案" class="headerlink" title="高可用方案"></a>高可用方案</h1><p>为什么要用保证redis的高可用？redis单点会带来哪些问题呢？</p>
<ul>
<li>单点故障问题<br>如果目前只有一台redis服务器在运行，发生机器故障，服务直接不可用，如果故障比较严重，磁盘损坏了，数据就损坏了，单台机器时没有办法保证数据的安全性的</li>
<li>容量瓶颈<br>redis是内存存储的，单机很容易受到内存容量的限制</li>
</ul>
<h2 id="主从复制模式"><a href="#主从复制模式" class="headerlink" title="主从复制模式"></a>主从复制模式</h2><p>主从复制，顾名思义，分为主节点和从节点，主节点负责写，从节点负责扩展主节点的读能力，并且可以将主节点的数据同步给从节点，一旦发现主节点发生故障，从节点可以随时顶上来</p>
<p><strong>主从复制模式面临的问题</strong></p>
<ul>
<li>并没有解决单点的写压力</li>
<li>主节点发生故障的时候，需要手动将从节点晋升为主节点，同时需要通知应用放更改主节点地址并重启，并且需要命令其他从节点复制新的主节点，整个过程需要人工干预</li>
<li>主节点的存储能力受到单机的限制</li>
</ul>
<p>redis 主从复制和sentinel架构示意图如下<br><img src="https://s1.ax1x.com/2020/04/07/GgEFqx.png" alt></p>
<h2 id="redis-sentinel-哨兵模式"><a href="#redis-sentinel-哨兵模式" class="headerlink" title="redis sentinel 哨兵模式"></a>redis sentinel 哨兵模式</h2><p>哨兵模式实际上就是在主从复制的基础上，加上了一层监控的哨兵节点。Redis-sentinel也是官方提供的高可用方案，哨兵模式是在2.6以后开始提供的，如果需要在生产上使用，尽量使用2.8之后的版本，比较稳定。哨兵模式下在主节点发生故障时，可以实现自动的主备切换，并且可以监控多个主从集群，哨兵节点本身也支持集群，毕竟哨兵只有单个节点也无法支持哨兵节点的高可用，并且如果唯一的哨兵如果宕机了，哨兵模式又变回主从复制模式了，又将无法自动的进行主备切换了。<br>客户端连接的是哨兵节点，只要连接任意一个哨兵节点，就可以获得redis主从集群中的信息。</p>
<p><img src="https://s1.ax1x.com/2020/04/16/JEEvHs.png" alt><br>图片引用自<a href="https://juejin.im/post/5d76f54b6fb9a06aeb10e53c#heading-8" target="_blank" rel="noopener">Redis哨兵（Sentinel）模式快速入门</a></p>
<h3 id="哨兵节点的作用"><a href="#哨兵节点的作用" class="headerlink" title="哨兵节点的作用"></a>哨兵节点的作用</h3><h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a><strong>监控</strong></h4><p>sentinel 会不间断的检查主服务器和从服务器是否正常运行</p>
<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a><strong>通知</strong></h4><p>当被监控的某个redis服务器如果出现问题，sentinel通过api脚本向管理员或者其他应用程序发送通知</p>
<h4 id="自动故障迁移"><a href="#自动故障迁移" class="headerlink" title="自动故障迁移"></a><strong>自动故障迁移</strong></h4><p>当主节点不能正常工作时，sentinel会开始一次自动的故障迁移，它将会与失效主节点是主从关系的其中一个主节点的其中一个从节点升级为新的主节点，并且将其他的从节点指向新的主节点。</p>
<h4 id="配置提供者"><a href="#配置提供者" class="headerlink" title="配置提供者"></a><strong>配置提供者</strong></h4><p>在redis sentinel模式下，客户端在初始化连接的是sentinel的集合，从中获取主节点的信息。</p>
<h3 id="主观下线-SDOWN"><a href="#主观下线-SDOWN" class="headerlink" title="主观下线(SDOWN)"></a>主观下线(SDOWN)</h3><p>主观下线其实是指单个sentinel实例对节点做出的下线判断，默认情况下，每个sentinel会以每秒一次的频率对redis节点和其他sentinel节点发送PING命令，并通过节点的回复来判断是否在线。</p>
<p>主观下线适用于所有主节点和从节点。如果在down-after-milliseconds毫秒内，sentinel没有收到目标节点的有效回复(+PONG,-LOADING,-MASTERDOWN)，则会判定为该节点为主观下线</p>
<h3 id="客观下线-ODOWN"><a href="#客观下线-ODOWN" class="headerlink" title="客观下线(ODOWN)"></a>客观下线(ODOWN)</h3><p>客观下线是指多个sentinel实例对同一个实例进行主观下线判断。</p>
<p>客观下线只适用于主节点，如果哨兵节点发现主节点主观下线后，会通过is-master-down-by-addr命令向其他sentinel节点询问该节点的状态，若果超过<quorum>个数的节点认为主节点不可达(主节点已经主观下线)，则sentinel节点会判定主节点为客观下线，只有发现主节点客观下线后，才会开启自动的故障迁移</quorum></p>
<h3 id="自动故障迁移-automatic-failover-过程"><a href="#自动故障迁移-automatic-failover-过程" class="headerlink" title="自动故障迁移(automatic-failover)过程"></a>自动故障迁移(automatic-failover)过程</h3><ol>
<li>sentinel发现主节点主观下线，修改其状态为SDOWN</li>
<li>sentinel和其他sentinel节点确认master是否down掉(SENTINEL is-master-down-by-addr)，确认其状态为客观下线(ODOWN),</li>
<li>sentinel间进行leader选举，由被选出的leader sentinel节点来进行后续的故障切换工作，选举基于Raft协议</li>
<li>sentinel节点开始进行故障切换，并选出合适的从节点作为主节点</li>
<li>对选出的从节点执行 slaveof no one将其晋升为新的主节点</li>
<li>对其余的从节点发送命令，使其变为新的主节点的从节点，并且从新的主节点复制数据</li>
<li>leader sentinel继续监控已下线主节点，一旦其重新上线，就把他降级为新的主节点的从节点，并且从新的主节点中复制数据</li>
</ol>
<h3 id="leader哨兵节点选举"><a href="#leader哨兵节点选举" class="headerlink" title="leader哨兵节点选举"></a>leader哨兵节点选举</h3><ol>
<li><p>某个sentinel发现master节点主观下线后，执行以下操作</p>
<ul>
<li>如果该哨兵节点没有投过票，它就成为candidate</li>
<li>如果该哨兵节点已经投过票，则在2倍的故障时间内就不会成为leader，也就是相当于一个follower</li>
</ul>
</li>
<li><p>sentinel节点成为candidate后执行以下操作</p>
<ul>
<li>更新故障转移状态为start</li>
<li>令当前epoch + 1,即发起新一轮的选举,在sentinel中epoch相当于Raft协议中的term</li>
<li>向其他节点发送SENTINEL is-master-down-by-addr指令，该命令包含自己的epoch</li>
<li>投自己一票，投票的方式是将自己master结构中的leader和leader_epoch改成投给的sentinel和它的epoch</li>
</ul>
</li>
<li><p>其他节点收到Candidate的SENTINEL is-master-down-by-addr命令，如果收到命令的sentinel判断发现当前epoch和通过命令收到的epoch一样，证明它已经投过票了，当前epoch内该sentinel就只能成为follower</p>
</li>
<li><p>candidate会不断统计自己的票数，直到他发现认同他成为leader超过一半且超过它配置的quorum，则该candidate成为leader哨兵节点</p>
</li>
<li><p>在一个选举时间内，如果一个candidate没有获得超过一半的票数且超过quorum,则该次选举失败</p>
</li>
<li><p>如果在一个epoch内，没有一个candidate获得更多的票数，则2倍故障转移的时间后，candidate增加epoch并重新投票</p>
</li>
</ol>
<h3 id="master节点选举"><a href="#master节点选举" class="headerlink" title="master节点选举"></a>master节点选举</h3><p>从已经宕机的主节点的从节点中挑选一个节点作为主节点，这个主节点是按照以下规则选出来的</p>
<ul>
<li>slave优先级(手动配置的) 如果有配置最高的slave节点，则返回，没有则继续</li>
<li>复制偏移量最大的(对主节点数据复制的最完整的从节点)，如果有则返回，没有则继续</li>
<li>启动最早的slave节点(run_id最小)</li>
</ul>
<h2 id="redis-cluster"><a href="#redis-cluster" class="headerlink" title="redis cluster"></a>redis cluster</h2><p>来聊redis cluster之前先来聊聊几个问题 </p>
<h3 id="水平扩展性"><a href="#水平扩展性" class="headerlink" title="水平扩展性"></a>水平扩展性</h3><p>水平扩展性或者说给系统中添加节点的能力，对于redis来说特别重要，redis只能进行垂直扩展(给予redis进程更多的CPU或者内存)，不过垂直扩展的特点也很明显，很快就会变得非常昂贵并且变得无法管理。</p>
<p>我们只能通过把redis中的数据进行分区，将不同分区的数据存储到不同的redis实例中，很多公司针对redis已经实现了自己的分区方案，不过大部分方案都是在客户端进行分区，也就是，数据在哪个节点进行读写是客户端来决定的，这个方法的缺点也很明显，所有的客户端都要实现这个相同的分区策略，并且连接到同一个redis实例的不同的redis客户端将会紧紧的耦合在一起。</p>
<p>另一种分区策略对客户端进行了解耦，就是用代理进行协助分区，Twitter就采用了这种分区策略，在这种方式下，<br>proxy就像一个在客户端和redis实例之间的一个单独的节点负责处理数据分区，虽然这种方式给客户端解耦，但是又引入了proxy单点故障的问题，又需要考虑proxy的高可用问题，还有一个问题就是如果将来需要添加或者删除节点的时候，又会带来数据的重新分区，如果只是用redis做缓存的话，这个问题没什么大不了的，但是如果用来做数据存储，只是改变分区策略可能会引起数据的“丢失”(原来的key值可能会被分区到别的redis实例上面去了)，并且这个新的redis实例上还没有数据，调整了分区策略后必须要进行数据迁移</p>
<h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>当在一个大型企业级应用中依赖一个数据库的时候，是不允许数据库有停机时间的，现代的数据库必须要尽可能地有容灾和容错能力，并且不需要人为干预。尽管redis实例很少发生宕机，但是也有一些异常情况会导致redis实例不可用，由于没有好的redis高可用方案，一些公司开始自行研发自己的redis高可用方案，但是大部分用户都没有高可用方案，并且一些stackoverflow上面的问答都太专业化了，普通用户根本就被抛弃了，于是redis团队立刻研发了一套高可用方案redis sentinel,这是一个官方的高可用方案，但是引入了额外的复杂度，并且这种方案并不提供主节点的水平扩展，在redis实例外还需要3台额外的机器(存放哨兵节点)。</p>
<p>为了解决上述问题，redis 3.0.0发布了redis cluster ，redis cluster是一个多主多从并且去中心的架构，redis cluster简而言之就是一个数据分片策略，它可以在集群运行的时候将数据重新分片到其他节点上面，并且提供了故障切换的方法可以确保系统可以应对各种各样的故障。redis cluster使用hash分区将key分配到16,384个hash槽内，集群的每一个主节点负责一部分hash槽，集群中的每一个从节点负责复制指定主节点的数据，并且可以重新分配给别的主节点或者是被选举为新的主节点，主节点接收来自客户端的读和写请求，从节点不与客户端做任何交互，只做主节点的数据备份。</p>
<p><img src="https://img-blog.csdn.net/20180902175117548?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmU5MDU2NjE0MzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br>图片引用自<a href="https://blog.csdn.net/love905661433/article/details/82317635" target="_blank" rel="noopener">Redis Cluster集群使用与原理</a></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://juejin.im/post/5d76f54b6fb9a06aeb10e53c#heading-8" target="_blank" rel="noopener">Redis哨兵（Sentinel）模式快速入门</a><br><a href="https://juejin.im/post/5e47cbe451882549522ab508#heading-17" target="_blank" rel="noopener">Redis 知识汇总</a><br><a href="https://www.credera.com/blog/technology-insights/open-source-technology-insights/an-introduction-to-redis-cluster/" target="_blank" rel="noopener">An Introduction to Redis Cluster</a></p>
<p>关于Raft协议，<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">这个网站</a>上面有动画演示，非常容易理解，可以去了解下</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/04/16/about-redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/04/16/about-redis/" itemprop="url">聊聊中间件之redis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-16T11:28:01+08:00">
                2020-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>
不知不觉4月份已经过去大半了，转眼间自己已经失业半个月了，感觉还有好多东西没有复习，不管怎么样，不能让自己闲下来,今天就来整理一下redis相关的内容
</p>

<h1 id="about-redis"><a href="#about-redis" class="headerlink" title="about redis"></a>about redis</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。  --- wikipedia</span><br></pre></td></tr></table></figure>

<p>redis是一款基于内存的数据库，即NOSQL,采用单线程模型，能支持10W的并发<br>常用的数据结构 String List Set ZSet Hash<br>持久化方式:RDB(快照)，AOF（日志追加）</p>
<h1 id="redis为什么高性能？"><a href="#redis为什么高性能？" class="headerlink" title="redis为什么高性能？"></a>redis为什么高性能？</h1><ul>
<li>单线程模型避免线程上下文切换问题</li>
<li>纯内存操作</li>
<li>核心基于非阻塞的IO多路复用</li>
</ul>
<h1 id="redis中的数据结构"><a href="#redis中的数据结构" class="headerlink" title="redis中的数据结构"></a>redis中的数据结构</h1><h2 id="string字符串-Simple-Dynamic-String-动态字符串"><a href="#string字符串-Simple-Dynamic-String-动态字符串" class="headerlink" title="string字符串 Simple Dynamic String(动态字符串)"></a>string字符串 Simple Dynamic String(动态字符串)</h2><p>String是redis里面最简单的key-value类型了，它的value不仅可以是String还可以是数字，它也是Memcached中的唯一的数据类型，redis String底层使用SDS(Simple Dynamic String)实现,常见的用法就是缓存、计数等功能，常用指令 set get decr(-1) incr(+1) mget(获取一个或多个给定key的值)</p>
<h2 id="list-列表"><a href="#list-列表" class="headerlink" title="list 列表"></a>list 列表</h2><p>list就是列表，在redis底层是用链表实现的，通过列表可以轻松实现最新消息列表等与插入序有关的业务。<br>常用指令 lpush(链表头插入一个元素),lpop(链表头删除一个元素),rpush,rpop,lrange(获取指定范围内的元素)</p>
<h2 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h2><p>set就是一个集合，一堆不重复值得集合，利用redis提供的set可以存储一些集合性的数据，比如微博中一个人关注的人，粉丝等等，redis还对set提供了一系列的函数可以实现对集合的并、交、差，这就可以非常方便的实现共同好友、共同关注、二度好友等功能</p>
<p>常用指令 sadd(向一个集合中添加一个或多个元素) spop(移除一个随机元素) srem(移除一个或多个指定元素) smembers(获取集合所有成员) sunion(求并集)</p>
<h2 id="zset有序集合-内部实现为skip-list跳跃表"><a href="#zset有序集合-内部实现为skip-list跳跃表" class="headerlink" title="zset有序集合 内部实现为skip list跳跃表"></a>zset有序集合 内部实现为skip list跳跃表</h2><p>zset(又称sorted set),有序集合，比set增加了一个score(权重)的概念，使得集合中的元素可以按照score进行排序，这一特性特别适合做排行榜</p>
<h2 id="hash-字典"><a href="#hash-字典" class="headerlink" title="hash 字典"></a>hash 字典</h2><p>hash几乎可以等价于java中的hashmap,底层采用数组+链表的结构，常用于存储对象<br>常用指令 hget,hset,hgetall</p>
<h1 id="redis常见的使用场景"><a href="#redis常见的使用场景" class="headerlink" title="redis常见的使用场景"></a>redis常见的使用场景</h1><ul>
<li>缓存</li>
<li>单线程模型可做分布式锁</li>
<li>排行榜 有序集合可以实现</li>
<li>计数器 商品浏览量 视频播放数 redis 提供的incr 内存操作 性能非常好</li>
<li>分布式会话</li>
<li>社交网络 共同关注/共同好友 redis提供的hash和集合(交并差)</li>
</ul>
<h1 id="redis-分布式锁"><a href="#redis-分布式锁" class="headerlink" title="redis 分布式锁"></a>redis 分布式锁</h1><h2 id="单节点分布式锁"><a href="#单节点分布式锁" class="headerlink" title="单节点分布式锁"></a>单节点分布式锁</h2><p>单节点的分布式锁(只有一个master节点)往往是不可靠的，虽然实现起来很简单，但是如果主节点宕机或者没有来得及同步数据，给从节点导致从节点选举为master时候锁丢失，这种方案很明显是不可靠的</p>
<h3 id="setnx-del"><a href="#setnx-del" class="headerlink" title="setnx + del"></a>setnx + del</h3><p>执行业务前通过 setnx 获取锁，执行完业务删除锁，表面上看起来没什么问题，但是如果业务的执行出现了异常，再或者服务宕机没有来得及删除该锁，导致这个业务再次执行的时候再也获取不到这个锁,从而导致死锁，这样是行不通的</p>
<h3 id="setnx-expire"><a href="#setnx-expire" class="headerlink" title="setnx + expire"></a>setnx + expire</h3><p>业务先通过set nx获取锁，然后再通过expire命令为锁设置过期时间，这种情况实际上跟先加锁后删除的效果是一样的，如果业务执行出现了异常，expire没有被执行，业务还是无法获取这个锁，出现这样的问题的根本原因实际上就是因为 setnx + del || expire是两条指令，并非一个原子性操作，两个指令如果能同时执行就可以避免这样的问题 </p>
<h3 id="lua脚本-setnx-expire"><a href="#lua脚本-setnx-expire" class="headerlink" title="lua脚本 setnx + expire"></a>lua脚本 setnx + expire</h3><p>setnx + expire 本身不是原子性的，但是redis提供了单线程模型执行lua脚本，保证脚本在运行过程中不会被任意其他请求打断，通过lua脚本执行相同的命令即可保证这两条命令的原子性</p>
<h3 id="set-nx-ex"><a href="#set-nx-ex" class="headerlink" title="set nx  ex"></a>set nx  ex</h3><p>redis 2.6.12开始，set命令开始支持EX、NX、PX、XX等选项，可以完全替代setnx等操作，而且还是原子性的，可以执行通过set实现单节点的分布式锁。</p>
<h2 id="多节点redis分布式锁"><a href="#多节点redis分布式锁" class="headerlink" title="多节点redis分布式锁"></a>多节点redis分布式锁</h2><h3 id="RedLock-真正意义上的分布式锁"><a href="#RedLock-真正意义上的分布式锁" class="headerlink" title="RedLock(真正意义上的分布式锁)"></a>RedLock(真正意义上的分布式锁)</h3><p>假设当前有5个独立的redis master节点</p>
<ul>
<li>获取当前unix时间戳 以毫秒为单位</li>
<li>依次从5个实例尝试，使用相同的key和value获取锁，客户端在请求锁的时候，应该设置一个超时时间，防止在请求锁的时候避免由于服务端已经挂掉的时候，客户端还在死等响应结果。如果服务端没有在规定的超时时间内响应，客户端应该尽快从另外一个redis实例中获取锁</li>
<li>客户端使用当前时间减去开始获取锁的时间，就得到锁的使用时间，并且当且仅当从大多数redis节点都获取到锁的时候，并且锁使用的时间小于锁失败时间时，锁才获取成功</li>
<li>如果获取到了锁，锁的真正有效时间等于有效时间减去第三步获取锁所使用的时间</li>
<li>如果获取锁失败，客户端应该在所有的redis实例上进行解锁，防止某些节点获取到锁，但是客户端没有得到响应，从而导致接下来的一端时间里客户端不能重新获取锁</li>
</ul>
<p>但是这种分布式锁真的可靠吗？ 业务时间超过了分布式锁的可用时间，这个锁还有意义吗？</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/04/14/db-lock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/04/14/db-lock/" itemprop="url">谈谈mysql中的锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-14T14:25:07+08:00">
                2020-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天又来写博客了，没错今天又被面试官锤了，这次被锤的问题是关于mysql中关于锁的问题，特此整理下有关锁的问题，避免今后对这种问题再次犯同样的错误(꒦_꒦) </p>
<h1 id="什么是锁？为什么要加锁"><a href="#什么是锁？为什么要加锁" class="headerlink" title="什么是锁？为什么要加锁"></a>什么是锁？为什么要加锁</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">锁是计算机协调多个进程或纯线程并发访问某一资源的机制。在数据库中，除传统的计算资源(CPU,RAM,I/O)  </span><br><span class="line">的争用外,数据也是一种供许多用户共享的资源。如果保证数据并发访问的一致性、有效性是所有数据库必须解决  </span><br><span class="line">的一个问题，锁冲突也是影响数据库并发访问性能的一个因素，  </span><br><span class="line">从这个角度来看，锁对数据库而言显得尤为重要，也更加复杂。</span><br><span class="line">锁机制用于管理对共享资源的并发访问</span><br></pre></td></tr></table></figure>

<h1 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h1><p><img src="https://image-static.segmentfault.com/393/973/393973056-5ac1c82c4bc61_articlex" alt><br>图片引用自参考文章<a href="https://segmentfault.com/a/1190000014133576" target="_blank" rel="noopener">MySQL InnoDB锁机制全面解析分享</a></p>
<h2 id="按照加锁机制进行分类"><a href="#按照加锁机制进行分类" class="headerlink" title="按照加锁机制进行分类"></a>按照加锁机制进行分类</h2><ul>
<li><strong>乐观锁</strong>  乐观锁乐观地假定大概率不会发生更新冲突，访问、处理数据的时候不加锁，只在更新数据的时候查看版本号是否有冲突，有则处理、无则提交事务</li>
<li><strong>悲观锁</strong>  悲观锁悲观地假定大概率会发生更新冲突，访问或者处理数据前加排他锁，在整个数据处理过程中锁定数据，事务提交或者回滚后才释放锁</li>
</ul>
<h2 id="按照兼容性进行分类"><a href="#按照兼容性进行分类" class="headerlink" title="按照兼容性进行分类"></a>按照兼容性进行分类</h2><ul>
<li><strong>共享锁</strong> 也就是读锁，读操作之间互相不冲突，但是读操作跟写操作互相冲突，也就是会阻塞写请求</li>
<li><strong>排他锁</strong> 也就是写锁, 写操作之间互相冲突，写操作跟读操作互相冲突</li>
</ul>
<h2 id="按照锁的粒度进行分类"><a href="#按照锁的粒度进行分类" class="headerlink" title="按照锁的粒度进行分类"></a>按照锁的粒度进行分类</h2><ul>
<li><strong>表级锁</strong> mysql中锁定粒度最大的一种锁，对整张表进行加锁，实现简单，资源消耗较少，加锁快，不会出现死锁。由于锁定粒度最大，触发锁冲突的概率最高，并发度最低，myisam和innodb引擎都支持表级锁</li>
<li><strong>页级锁</strong> 开销和加锁时间介于表锁和行锁之间，会出现死锁，并发程度一般</li>
<li><strong>行级锁</strong> 开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发程度也最高</li>
</ul>
<h2 id="按照锁模式进行分类"><a href="#按照锁模式进行分类" class="headerlink" title="按照锁模式进行分类"></a>按照锁模式进行分类</h2><ul>
<li><strong>record lock</strong> 记录锁，对符合条件的行进行加锁，锁住索引项</li>
<li><strong>gap lock</strong>   间隙锁，对符合条件的记录行之间的间隙进行加锁，不包含符合条件的索引项本身，只是锁定记录的范围，其他事务不能在锁范围内插入数据，这样就防止了别的数据新增幻影行(幻读)</li>
<li><strong>next-key lock</strong> 锁定索引项本身和索引范围，即record lock + gap lock的结合 可解决幻读问题</li>
<li><strong>意向锁</strong>  为了允许表锁和行锁共存，实现多粒度锁机制，innodb还有两种内部使用的意向锁(表级锁)分为<ul>
<li><strong>意向共享锁(IS)</strong> 事务打算给数据行加共享锁，必须先取得该表的IS锁</li>
<li><strong>意向排他锁(IX)</strong> 事务打算给数据行加排他锁，必须先取得该表的IX锁<br>意向锁是在给某一行进行加锁的时候，mysql会自动为这一行所处的表进行加意向锁，无需用户任何处理,意向锁的作用我们可以看下面一个例子</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>时间</th>
<th>事务1</th>
<th>事务2</th>
</tr>
</thead>
<tbody><tr>
<td>t1</td>
<td>更新table a中某一行数据</td>
<td>do nothing</td>
</tr>
<tr>
<td>t2</td>
<td>do nothing</td>
<td>更新table a全表数据,需要获取表锁</td>
</tr>
<tr>
<td>t3</td>
<td>提交</td>
<td>—</td>
</tr>
<tr>
<td>t4</td>
<td>—</td>
<td>提交</td>
</tr>
</tbody></table>
<p>在上述例子中，事务1中在t1时刻对表中数据进行数据更新时，自动加该表的意向排他锁，这时事务2获取该表的写锁时会先判断是否和意向锁兼容，发现该表存在意向排他锁，锁类型不兼容，需要等待事务1提交后才能进行操作。<br>这样如果某张表存在行级锁，获取表锁的时候就不必遍历整张表判断是否存在行级锁，直接判断是否与表级的意向锁是否兼容就可以了，下面给出表级的意向锁和读写锁的兼容情况</p>
<table>
<thead>
<tr>
<th>—-</th>
<th>IS</th>
<th>IX</th>
<th>S</th>
<th>X</th>
</tr>
</thead>
<tbody><tr>
<td>IS</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
<td>冲突</td>
</tr>
<tr>
<td>IX</td>
<td>兼容</td>
<td>兼容</td>
<td>冲突</td>
<td>冲突</td>
</tr>
<tr>
<td>S</td>
<td>兼容</td>
<td>冲突</td>
<td>兼容</td>
<td>冲突</td>
</tr>
<tr>
<td>X</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
</tr>
</tbody></table>
<ul>
<li><strong>插入意向锁</strong> 插入意向锁是gap锁的一种，这种锁会在记录插入前设置。这种锁表示了多个事务在插入到相同的索引间隙的时候，只要他们不是插入到相同的位置上就不必彼此互相等待。在获取插入的排它锁之前，需要先获取插入意向锁</li>
</ul>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-insert-intention-locks" target="_blank" rel="noopener">insert-intention-locks</a></p>
<p>谈到这里其实可以聊聊今天被锤的一个面试问题,有关SQL优化相关的问题</p>
<h1 id="面试中被面试官锤的问题"><a href="#面试中被面试官锤的问题" class="headerlink" title="面试中被面试官锤的问题"></a>面试中被面试官锤的问题</h1><p><strong>表级锁了解吗？什么时候会触发表级锁？update语句什么情况下会触发表级锁？</strong></p>
<p>
现在mysql默认存储引擎都是innodb,那么innodb存储引擎下什么情况会进行锁表呢？这就要从mysql的索引讲起了
innodb中默认使用行级锁，这个行级锁锁的是索引记录，换句话说，如果你的SQL语句中如果没有索引，这时innodb会锁住谁呢？毫无疑问这个时候没有索引就会触发了表级锁,实际使用中我们要特别注意innodb行级锁的这个特性，不然会引起大量的锁冲突，从而影响并发性能, update语句中什么情况会触发表级锁可以看下面哪些情况会锁表
</p>

<p><strong>都有哪些情况innoDB会锁表呢</strong>？</p>
<p>其实不管是读操作(select)还是写操作(update,delete,insert),只要涉及到带有筛选条件的语句，如果筛选条件中没有用到索引，就会触发全表扫描，区别是读操作可能加读锁(也有可能不加锁,mvcc中的快照读是通过版本号实现的，不加读锁，当前读需要加读锁)，写操作默认需要对影响的数据集隐式加写锁,那么如果发现影响的数据集没有用到索引或者是索引效果不好(区分度不够高,导致需要扫描表中大部分数据)再或者全表扫描的时候，就会锁住整张表，导致默认的行级锁升级为表级锁，因此我们总结下以下情况会导致锁表</p>
<ul>
<li>全表更新 事务需要更新大部分数据或全部数据，如果使用行级锁，会导致事务执行效率低，从而导致其他事务长时间等待锁和更多的锁冲突</li>
<li>多表级联 事务涉及多张表，比较复杂的关联查询，很可能造成死锁，这种情况若能一次性锁住事务涉及的表，从而避免死锁，减少数据库事务回滚所带来的开销</li>
<li>本应部分更新，但是因为筛选条件中未用到索引或者索引区分度程度不高(innodb认为全表扫描比走索引效率更高导致索引失效的情况)，导致全表扫描，这个时候就要通过explain去查看下查询计划，看下查询语句是否真的用到了索引</li>
</ul>
<h1 id="锁优化部分"><a href="#锁优化部分" class="headerlink" title="锁优化部分"></a>锁优化部分</h1><ul>
<li>尽量让数据检索都通过索引来完成，避免无索引或者索引失效导致行级锁升级为表级锁</li>
<li>合理设计索引，以缩小加锁范围，避免间隙锁造成不该锁定的键值被锁定</li>
<li>尽量控制事务的大小，因为行级锁的复杂性会加大资源使用量以及锁定时间</li>
</ul>
<p>这里面实际上第三种情况是可以避免的，在做业务时，需要谨慎的加索引,在合适的列上创建索引，索引列区分程度是否高(主键索引和唯一索引不用说区分度百分百，如果能用到主键索引或者唯一索引就尽可能的使用这两种索引，如果不能使用，确保索引列区分程度够高)</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://segmentfault.com/a/1190000014133576" target="_blank" rel="noopener">MySQL InnoDB锁机制全面解析分享</a><br><a href="https://zhuanlan.zhihu.com/p/29150809" target="_blank" rel="noopener">MySQL锁总结</a><br><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-insert-intention-locks" target="_blank" rel="noopener">mysql官方文档#insert-intention-locks</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/04/13/mq-Rabbit-MQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/04/13/mq-Rabbit-MQ/" itemprop="url">消息队列之RabbitMQ</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-13T12:31:03+08:00">
                2020-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/rabbitmq/" itemprop="url" rel="index">
                    <span itemprop="name">rabbitmq</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天继续整理下跟RabbitMQ有关的内容，加深一下理解,还是避免被面试官锤。</p>
<h1 id="什么是消息队列-为什么要用消息队列"><a href="#什么是消息队列-为什么要用消息队列" class="headerlink" title="什么是消息队列,为什么要用消息队列"></a>什么是消息队列,为什么要用消息队列</h1><p>这里的内容在上一篇(<a href="https://kyo7701.github.io/blog/2019/08/11/message_queue/">谈谈消息队列</a>)内容中已经讲过了，这里就不再赘述了</p>
<h1 id="消息队列之RabbitMQ"><a href="#消息队列之RabbitMQ" class="headerlink" title="消息队列之RabbitMQ"></a>消息队列之RabbitMQ</h1><p>
RabbitMQ是一款消息队列软件，也被成为消息代理(Message Broker)或队列管理器(Queue manager)，他是一个由ErLang语言开发的AMQP的开源实现
</p>

<p>AMQP(Adavanced message queue),高级消息队列协议，它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可以传递消息，并且不受产品、开发语言等条件的限制。</p>
<p>这里引用了RabbitMQ官网的图片，AMQP的消息模型<br><img src="https://www.rabbitmq.com/img/tutorials/intro/hello-world-example-routing.png" alt><br>消息代理(messaging broker)从publisher(消息生产者)接收消息，并且将消息路由给消费者，由于AMQP是个网络协议，生产者、消息代理和消费者可以位于不同的机器上</p>
<h1 id="RabbitMQ中的基本概念"><a href="#RabbitMQ中的基本概念" class="headerlink" title="RabbitMQ中的基本概念"></a>RabbitMQ中的基本概念</h1><ul>
<li>Exchange 从生产者接收消息，并且根据exchange的类型将消息推送到对应的队列中</li>
<li>Binding queue和exchange的绑定，通过这个绑定rabbitmq可以知道如何正确地将消息路由到指定的queue上了</li>
<li>Routing key 生产者将消息发送给exchange的时候，rabbitmq 需要指定一个routing key来确定这个消息的路由规则，这个路由规则将决定消息如何路由到queue中</li>
<li>Users </li>
<li>Vhost,virtual host 是一种可以在同一个rabbitMQ实例中隔离多个不同的应用，不同的用户可以拥有不同virtual host的权限，每一个virtual host都可以拥有不同的queues和exchanges</li>
<li>Producer 应用中消息的生产者</li>
<li>Consumer 应用中消息的消费者</li>
<li>Queue 一个存储消息的buffer</li>
<li>Message 生产者通过rabbitMQ投递给消费者的消息</li>
<li>Connection 客户端应用程序和RabbitMQ之间的TCP连接,和生产者与RabbitMQ之间都是通过TCP连接建立的。</li>
<li>Channel 在Connection中的一个虚拟连接，队列中的消息的发布和消费</li>
</ul>
<p>由Exchange、Queue、RoutingKey三个才能决定一个从Exchange到Queue的唯一的线路</p>
<h1 id="exchange和exchange类型"><a href="#exchange和exchange类型" class="headerlink" title="exchange和exchange类型"></a>exchange和exchange类型</h1><p>Exchanges在AMQP模型中是消息被发送到的实体。Exchanges将消息路由到0个或更多个queue上面去，路由算法取决于exchange的类型和绑定规则，AMQP提供以下exchange类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>默认预定义的名字</th>
</tr>
</thead>
<tbody><tr>
<td>Direct Exchange</td>
<td>空串或者 amqp.direct</td>
</tr>
<tr>
<td>Fanout Exchange</td>
<td>amq.fanout</td>
</tr>
<tr>
<td>Topic Exchange</td>
<td>amq.topic</td>
</tr>
<tr>
<td>Headers Exchange</td>
<td>amq.match</td>
</tr>
</tbody></table>
<p>此外 AMQP中还定义了几个很重要的属性</p>
<ul>
<li>name </li>
<li>durability(broker重启后exchange是否还存在)</li>
<li>Auto-delete(当exchange上面的最后一个queue解绑后是否自动删除)</li>
<li>Arguments(可选参数，插件或者broker的特定功能会用到)</li>
</ul>
<p>下面的内容全部引用自rabbitmq官网，提供了AMQP协议的概述</p>
<h1 id="Default-Exchanges"><a href="#Default-Exchanges" class="headerlink" title="Default Exchanges"></a>Default Exchanges</h1><p>默认的exchange是一个broker预定义的没有名字的direct exchange，它有一个特殊的性质:所有新建的queue都会绑定到默认的exchange上面，并且routing-key和queue名相同</p>
<h1 id="Direct-Exchange"><a href="#Direct-Exchange" class="headerlink" title="Direct Exchange"></a>Direct Exchange</h1><p>direct exchange根据消息所带的routing-key将消息投递给对应的队列。direct exchange倾向于用作消息的单播路由(unicast routing),尽管它也可以用作多播路由(multicast routing)，工作原理:</p>
<ul>
<li>一个queue通过一个routing-key K绑定到一个exchange上</li>
<li>当一条routing-key为R的消息到达direct-exchange时，direct exchange会把消息投递给routing-key跟R相等的queue上面去</li>
</ul>
<p>direct exchange通常用于循环分配任务给多个工作者，需要注意的是，消息的负载均衡是发生在consumer之间的，并不是发生在queue之间，举个例子(一个direct exchange 通过一个routing-key绑定了多个queue,消息会发到多个queue中，一个queue中消息的消费并不影响另一个queue的消费,也就是不会发生抢消息的行为)</p>
<p><img src="https://www.rabbitmq.com/img/tutorials/intro/exchange-direct.png" alt><br>图片引用自<a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html" target="_blank" rel="noopener">rabbitmq官网</a></p>
<h1 id="Fanout-Exchange-扇形交换机"><a href="#Fanout-Exchange-扇形交换机" class="headerlink" title="Fanout Exchange 扇形交换机"></a>Fanout Exchange 扇形交换机</h1><p>扇形交换机会把他收到的消息发送到所有绑定到它的queue中,并且这里的routing-key是被忽略的。如果有n个queue绑定到了扇形交换机上面，当一条新消息发布到交换机中时，消息会复制n份投递到所有的n个queue中，扇形交换机特别适合做广播消息<br><img src="https://www.rabbitmq.com/img/tutorials/intro/exchange-fanout.png" alt><br>图片引用自<a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html" target="_blank" rel="noopener">rabbitmq官网</a></p>
<p>因为扇形交换机会把消息广播到所有的queue中，他的使用场景非常相似:</p>
<ul>
<li>很多大型多人在线游戏会用它处理排行榜更新或其他全局事件</li>
<li>体育新闻网站可以准实时地将比分发送给移动客户端</li>
<li>分布式系统可以将不同的状态和配置更新进行广播</li>
<li>可以通过扇形交换机来实现分发消息给群聊中 的用户</li>
</ul>
<h1 id="topic-exchange"><a href="#topic-exchange" class="headerlink" title="topic exchange"></a>topic exchange</h1><hr>
<p>未完待续</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.cloudamqp.com/blog/2015-05-18-part1-rabbitmq-for-beginners-what-is-rabbitmq.html" target="_blank" rel="noopener">for RabbitMQ beginners- what is RabbitMQ?</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/04/10/db-index/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/04/10/db-index/" itemprop="url">谈谈数据库中的索引</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-10T21:01:27+08:00">
                2020-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天来聊聊数据库当中的索引，想整理一下关于索引的基础内容，不仅是因为我最近比较闲，而且因为我今天面试中聊到索引的内容，感觉自己回答的特别水，特此整理一下相关的内容加深一下记忆，以便于下回面试的时候不至于被面试官锤(这么简单的内容你特么都答不出来,辣鸡)，本文要讲的索引全部是在mysql数据库中的，因此后续再说索引，说的就是mysql数据库中的索引，不再赘述。</p>
<hr>
<h2 id="索引的定义"><a href="#索引的定义" class="headerlink" title="索引的定义"></a>索引的定义</h2><p>在开始看mysql中的索引之前，我们先了解下在DMBS系统中索引的定义是怎样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据库索引，是数据库管理系统的一个排序的数据结构,</span><br><span class="line">以协助快速查询、更新表中数据.     ------ 维基百科</span><br></pre></td></tr></table></figure>

<h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><p>那么索引有哪些类别呢？这里从几个不同的角度来分析有哪些类别的索引</p>
<h3 id="物理存储角度"><a href="#物理存储角度" class="headerlink" title="物理存储角度"></a>物理存储角度</h3><ul>
<li><strong>聚集索引(又称聚簇索引)</strong></li>
<li><strong>非聚集索引(又称非聚簇索引)</strong></li>
</ul>
<p>聚集索引的特点是，数据库中表数据的物理顺序和索引顺序相同，而非聚集索引在数据库中的索引的逻辑顺序和表中数据的物理顺序并不相同。所以说聚集索引和非聚集索引是从物理存储角度来划分的，此外，因为数据表的结构只能有一个，所以一张表的聚集索引只能有一个。</p>
<h3 id="逻辑角度"><a href="#逻辑角度" class="headerlink" title="逻辑角度:"></a>逻辑角度:</h3><ol>
<li><strong>主键索引</strong> 一种特殊的唯一索引，不允许有空值</li>
<li><strong>普通索引或者单列索引</strong> 最基本的索引，没有任何限制</li>
<li><strong>联合索引或者多列索引</strong> 建立在多个列上的索引，被称为联合索引，遵循最左前缀原则</li>
<li><strong>唯一索引</strong>   与普通索引类似，不同的是唯一索引要求索引的值必须唯一，但允许有空值</li>
</ol>
<p>在这里顺便介绍下 上述的索引的创建和删除，水一下</p>
<ul>
<li>普通索引</li>
</ul>
<p>创建</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`table_name`</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> <span class="string">`index_name`</span>(<span class="string">`column_name`</span>);</span><br></pre></td></tr></table></figure>

<p>删除</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`table_name`</span> <span class="keyword">DROP</span> <span class="keyword">INDEX</span> <span class="string">`index_name`</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>联合索引</li>
</ul>
<p>创建</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`table_name`</span> <span class="keyword">ADD</span> <span class="keyword">INDEX</span> <span class="string">`index_name`</span>(<span class="string">`column_name_1`</span>,<span class="string">`column_name_2`</span>);</span><br></pre></td></tr></table></figure>

<p>删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `table_name` DROP INDEX `index_name`;</span><br></pre></td></tr></table></figure>

<ul>
<li>主键索引</li>
</ul>
<p>创建</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可以在建表时指定 </span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`table_name`</span> <span class="keyword">add</span> PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure>

<p>删除(如果主键索引是自增列，那么删除主键将不满足自增列必须是索引列的定义,所以需要额外做一些手脚才能删除)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`table_name`</span> <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>唯一索引</li>
</ul>
<p>创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `table_name` ADD UNIQUE INDEX `index_name`(`column_name`);</span><br></pre></td></tr></table></figure>

<p>删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `table_name` DROP INDEX `index_name`;</span><br></pre></td></tr></table></figure>

<h3 id="数据结构角度"><a href="#数据结构角度" class="headerlink" title="数据结构角度"></a>数据结构角度</h3><ol>
<li>B-Tree索引，在mysql中B-Tree索引实际上是由B+树结构实现的，更适合于范围查询</li>
<li>hash 索引 等值比较    效率非常高,通常用于精确内容查找(etc: in(),=, &lt;=&gt;,这里的“&lt;=&gt;”等价于=),但是mysql的InnoDB存储引擎并不支持hash索引</li>
<li>full-text索引(全文索引)</li>
</ol>
<h2 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h2><ul>
<li>索引大大减少了服务器需要扫描的数据量</li>
<li>索引可以帮助服务器避免排序和临时表</li>
<li>索引可以将随机I/O变为顺序I/O</li>
</ul>
<p>摘自《高性能mysql》第5.2节</p>
<h2 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h2><ul>
<li>创建索引和维护索引需要花费时间，并且随着数据量的增加所耗费的时间也会增加</li>
<li>虽然索引大大提高了查询速度，但是同时会降低更新表(insert,update,delete)的速度,mysql不仅要保存数据，还要保存索引文件</li>
<li>建立索引会建立占用磁盘空间的索引文件，一般情况下这种问题不大，但是如果一张大表上建立多种组合索引，索引文件会膨胀的很快。</li>
<li>如果某个列数据上包含许多重复的内容，那么在这列上建立索引就没有太大的效果(索引列区分程度不高，计算公式select distinct(col) from table/select count(*) from table)</li>
<li>非常小的表，大部分情况下简单的全表扫描更高效</li>
</ul>
<h2 id="索引为什么能加速数据查询？"><a href="#索引为什么能加速数据查询？" class="headerlink" title="索引为什么能加速数据查询？"></a>索引为什么能加速数据查询？</h2><p>在没有索引的情况下，在数据库中查询数据是需要进行全表扫描的，如果一张表只有几十条数据，这个时候不加索引是完全没有问题的，但是如果数据量很大呢？我们都知道数据库中的数据是存在磁盘上的，取数据的时候是把需要的数据块读取到内存中，然而内存是有限的，并不能把所有的数据一次性全部取出，所以我们拿到想要的数据可能会发生很多次磁盘IO(磁盘IO是很重的操作，速率远小于从内存中直接操作，所以提升效率的关键是尽量减少磁盘IO次数)，如果是全表扫描可能发生很多次磁盘IO所以会很慢，以mysql为例，mysql的innodb引擎是以B+树作为索引树，1个3层的B+数大概可以存储2000W数据，也就是说通常情况下，我们对表中数据(不超过3层B+树最大容量情况)的查询一般需要3次磁盘IO就能拿到磁盘数据了，如果全表扫描这种效率是不堪设想的，而为什么索引不用二叉树(有序时退化为单链表，退化为线性查找)、平衡二叉树(一个节点的子节点数量太少，树的平均高度过高)、B树(非叶子节点既存数据元素，又存储指针，可存放的数据量更少)可以自行了解一下，这里不过多解释了，这也就是为什么索引能加速数据查询</p>
<h2 id="索引原理？"><a href="#索引原理？" class="headerlink" title="索引原理？"></a>索引原理？</h2><p>未完待续</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://segmentfault.com/q/1010000003832312" target="_blank" rel="noopener">MySQL有哪些索引类型 ?</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/blog/images/avatar.jpg" alt="mr_cris">
            
              <p class="site-author-name" itemprop="name">mr_cris</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/blog/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/blog/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mr_cris</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>  总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  














  





  

  

  

  
  

  

  

  

</body>
</html>
