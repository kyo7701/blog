<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="cris&#39;s blog">
<meta property="og:url" content="https://kyo7701.github.io/blog/index.html">
<meta property="og:site_name" content="cris&#39;s blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="cris&#39;s blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://kyo7701.github.io/blog/">





  <title>cris's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cris's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/05/11/about-lock-of-java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/05/11/about-lock-of-java/" itemprop="url">聊聊Java中的锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-11T17:03:14+08:00">
                2020-05-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>锁机制不仅仅是面试中是一个很高频的面试问题，而且是我们开发中不得不了解的一个内容，今天我们就来聊聊Java中的各中锁</p>
<h1 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h1><h1 id="共享锁-VS-排他锁"><a href="#共享锁-VS-排他锁" class="headerlink" title="共享锁 VS 排他锁"></a>共享锁 VS 排他锁</h1><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>共享锁又被称为读锁，可以被多个线程所持有，如果线程A对共享资源T加了共享锁，则线程A只能读取共享资源T，并不能对其进行修改，其他线程只能对共享资源T加共享锁，不能加排它锁</p>
<h2 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h2><p>排它锁又被称为写锁，如果线程A对共享资源T加了排它锁，则线程A既能对共享资源T读又能进行写操作，其他线程不能对共享资源T加任何类型的锁，其中JDK中的synchronized和Lock中写锁的实现类都是排它锁</p>
<h1 id="自旋锁-VS-自适应自旋锁"><a href="#自旋锁-VS-自适应自旋锁" class="headerlink" title="自旋锁 VS 自适应自旋锁"></a>自旋锁 VS 自适应自旋锁</h1><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁实际上是按照在线程获取锁失败的时候是否会是否挂起该线程来划分的，自旋锁是指在线程获取共享资源的时候获取锁失败了，认为等一小会儿(进行固定次数的自旋)，就可以获得该资源的锁，而不是通过CPU阻塞线程，切换线程的时间片这种方式，通常情况下这比CPU进行线程切换(涉及到用户态和内核态的转换)的开销要小得多，如果自旋完成后，前面锁定资源的线程已经释放了锁，那么当前线程可以拿到锁，不过这是一个不太确定的情况，有可能自旋完成后，前面的线程还没有释放该资源锁。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程可能只是浪费CPU的时间片，所以自旋的等待时间需要有一定的限度，如果自旋超过了限定次数，没有获得资源锁，就应该挂起线程。</p>
<p>自旋是通过CAS实现的，类似AtomicInteger中调用unsafe进行自增(do-while循环)就是一个自旋操作，如果修改失败就通过循环修改值，直至修改成功</p>
<h2 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h2><p>自适应自旋锁是在自旋锁上面进行的改进，它的自旋时间不再是固定值，而是由在同一个自旋锁上一次的自选时间和拥有者的状态来决定的，如果同一个锁对象上，刚刚成功获取过锁，则虚拟机认定它很有可能再次成功，那么它的自旋时间可以允许变得更长，反之则更短</p>
<h1 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h1><p>可重入锁又被称为是递归锁，是指同一个线程在外层方法已经拿到锁的情况下，在进入内层方法的时候就会自动拿到锁，java中的Synchronized和ReentrantLock都是可重入锁，可重入锁在一定程度上可以避免死锁的发生。</p>
<p>比如类A有两个实例方法C,D，这两个方法都被sychronized修饰，在C方法内部调用了D，那么某一个线程在进入C已经拿到锁的情况下进入D方法就会自动拿到锁</p>
<h1 id="无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h1><p>这些锁实际上是按照锁的状态来区分，并且是专门针对synchronized关键字来说的，但是在对这四种锁描述之前需要对一些概念进行了解:对象头和Monitor</p>
<h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>Hotspot虚拟机中，对象在虚拟机中的布局分为3部分，分别是对象头、实例数据、对齐填充<br>普通对象的对象头包括两部分:MarkWord和ClassMetaData Address(类型指针)，如果是数组对象还额外包括一个额外的数组长度部分</p>
<p><strong>Markword</strong><br>用于存储对象自身的运行数据，如HashCode,GC分代年龄，锁状态标志，线程持有的锁、偏向线程ID,偏向时间戳等等，占用内存大小跟虚拟机位长一致<br><strong>Class MetaData Address</strong><br>类型指针，指向对象的类元数据，虚拟机通过这个指针确定该对象是哪个类的实例</p>
<p><strong>Array Length</strong><br>数组长度</p>
<p>对象需要存储的数据很多，这已经超出了32bit或者是64bit能表示的限度，此外对象头信息是对象自定义的数据无关的额外存储成本，在考虑虚拟机空间效率的时候，MarkWord被设计成一个非固定的数据结构用来在极小的空间里面存储尽量多的信息，它会根据对象的状态复用自己的存储空间，也就是说MarkWord中存储的内容会伴随着锁的状态变化而变化。</p>
<p>例如在32bit的hotspot的虚拟机中，其各个锁状态下的存储内容如下所示</p>
<p><img src="https://s1.ax1x.com/2020/05/11/YYNgrn.jpg" alt><br>图片引用自<a href="https://blog.csdn.net/u010723709/article/details/50341631" target="_blank" rel="noopener">Synchronized与三种锁态</a></p>
<p><strong>Monitor</strong><br>Monitor可以理解为一个同步工具或一种同步机制。每一个Java对象都有一个看不见的锁，称为内部锁或Monitor锁，这个Monitor锁实际上就存在于对象的对象头中，对象头中的若干标志位用于标识锁的锁定状态和被哪个线程拥有，在一个线程需要使用一个对象之前，需要先获得它的内置锁，使用之后还需要释放这个内置锁，在使用过程中其它线程无法获取这个锁。 在进入同步代码块的时候，会在线程的栈中创建一个叫Lock Record的内存区域用来存储锁对象的MarkWord的拷贝，官方把这个拷贝称为Displaced Mark Word。LockRecord是线程私有的数据结构，每一个锁住的MarkWord都会与一个LockRecord相连(MarkWord中的指针指向LockRecord的起始地址)，同时LockRecord中有一个Owner字段存放该线程的唯一标识，表示该锁被这个线程占用。</p>
<p><strong>Synchronized概述</strong><br>Synchronized在JVM里面的实现是基于进入和退出Monitor对象来获取对象锁从而实现方法同步和代码块同步，不同虚拟机的实现细节可能不一样，但都可以通过成对的MonitorEnter和MonitorExit指令来实现，而MonitorEnter和MonitorExit的执行是通过调用操作系统的互斥原语Mutex Lock来实现的，被阻塞的线程会被挂起等待重新调度，会导致CPU在用户态和内核态两个态之间进行切换，比较耗性能，这也是为什么大家对synchronized的一贯印象就是性能较差的原因，jdk在1.6之后对sychronized进行了一系列调整，后来实际上跟Lock的性能不相上下，其实默认还是推荐用synchronized的，语义清晰、操作简单、无需手动关闭</p>
<p>同步方法是通过ACC_SYNCHRONIZED标识符来实现同步的<br>同步代码块是通过MonitorEnter和MonitorExit两个指令来实现的</p>
<p><strong>MonitorEnter</strong><br>插入在同步代码块的起始位置，当代码执行到该指令时，将会尝试获取该对象的monitor的所有权，即尝试获取该对象的锁<br><strong>MonitorExit</strong><br>MonitorExit插入在方法结束和异常处，JVM保证每个MonitorEnter必须有相应的MonitorExit</p>
<h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><p>无锁没有对共享资源进行锁定</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Hotspot虚拟机的作者发现在大多数情况下不仅不存在锁的竞争，甚至锁总是同一个线程多次获得，所以为了降低获取锁的代价而引入了偏向锁。偏向锁就是指一段代码一直被一个线程访问，那么线程会自动获取锁，直接执行同步代码块，从而降低获取锁的代价</p>
<h3 id="锁的获取"><a href="#锁的获取" class="headerlink" title="锁的获取"></a>锁的获取</h3><p>当一个线程第一次访问一段同步代码时，会尝试获得对象的偏向锁，即通过CAS在对象头中存储偏向锁偏向线程的线程id,同时将锁的是否是偏向位置1,当线程再次进入和退出同步代码的时候不再通过CAS进行加锁和解锁，而是通过检测对象头中的MarkWord中的指针是否指向的是当前线程，如果是</p>
<ol>
<li>获取对象的markword</li>
<li>检测MarkWord是否为可偏向状态</li>
<li>如果为可偏向，并且markword中指向的线程是当前线程则执行同步代码</li>
<li>如果为可偏向，但指向的线程不是当前线程，通过cas竞争，若竞争成功，则执行同步代码，如果不成功执行5</li>
<li>偏向锁竞争不成功，证明存在多线程竞争情况，此时偏向锁不再适用，到达全局安全点，获得偏向锁的线程将被挂起，偏向锁升级为轻量级锁，被阻塞在安全点的线程继续往下执行同步代码</li>
</ol>
<h3 id="锁的释放"><a href="#锁的释放" class="headerlink" title="锁的释放"></a>锁的释放</h3><p>线程拥有的偏向锁并不会主动释放，需要等待其他线程来竞争，偏向锁的撤销需要等待全局安全点(没有正在执行的代码的时间点),步骤如下</p>
<ul>
<li>判断锁对象是否还处于锁定的状态，如果否，则将其恢复到无锁状态，允许其它线程竞争，如果还处于锁定状态，则挂起拥有偏向锁的线程，并将指向该线程的lock record的指针放入对象头的mark word中，升级为轻量级锁(00),然后恢复刚才拥有偏向锁的线程，进入轻量级锁的竞争模式</li>
</ul>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><h4 id="锁的获取-1"><a href="#锁的获取-1" class="headerlink" title="锁的获取"></a>锁的获取</h4><h4 id="锁的释放-1"><a href="#锁的释放-1" class="headerlink" title="锁的释放"></a>锁的释放</h4><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><h1 id="Synchronized用法"><a href="#Synchronized用法" class="headerlink" title="Synchronized用法"></a>Synchronized用法</h1><h2 id="修饰实例方法"><a href="#修饰实例方法" class="headerlink" title="修饰实例方法"></a>修饰实例方法</h2><h2 id="修饰静态方法"><a href="#修饰静态方法" class="headerlink" title="修饰静态方法"></a>修饰静态方法</h2><h2 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h2><h1 id="Synchronized原理"><a href="#Synchronized原理" class="headerlink" title="Synchronized原理"></a>Synchronized原理</h1><h1 id="Synchronized与Lock的区别"><a href="#Synchronized与Lock的区别" class="headerlink" title="Synchronized与Lock的区别"></a>Synchronized与Lock的区别</h1><p>未完待续</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">不可不说的Java“锁”事</a></p>
<p><a href="https://blog.csdn.net/u013256816/article/details/51204385" target="_blank" rel="noopener">Java中的锁</a></p>
<p><a href="https://blog.csdn.net/qq_42862882/article/details/89375340" target="_blank" rel="noopener">JAVA锁优化和膨胀过程</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/05/08/about-java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/05/08/about-java/" itemprop="url">java基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-08T10:49:49+08:00">
                2020-05-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java基础之集合类"><a href="#Java基础之集合类" class="headerlink" title="Java基础之集合类"></a>Java基础之集合类</h1><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>Collection接口继承自Iterable接口，Iterable接口允许使用foreach方式遍历，并且定义了一个迭代器</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>List接口继承自Collection接口，存储一组<strong>不唯一</strong>的<strong>有序</strong>(插入序)的对象。<br>采用线性列表存储，长度可以动态改变，可以通过索引访问</p>
<h3 id="ArrayList-和LinkedList区别"><a href="#ArrayList-和LinkedList区别" class="headerlink" title="ArrayList 和LinkedList区别"></a>ArrayList 和LinkedList区别</h3><p>ArrayList底层用数组实现，随机访问效率高(O(1)),插入删除效率低(O(n),需要移动后面元素)<br>LinkedList底层用链表实现，随机访问效率低(O(n)),插入删除效率高(O(1))</p>
<h3 id="ArrayList-和vector的区别"><a href="#ArrayList-和vector的区别" class="headerlink" title="ArrayList 和vector的区别"></a>ArrayList 和vector的区别</h3><p>Vector的所有方法都是同步方法,而ArrayList不是，如果需要用到线程安全的list可以考虑用Vector，不过即使需要用线程安全的list我们也是推荐用CopyOnWriteList而不是用Vector</p>
<h3 id="ArrayList是否是线程安全的？"><a href="#ArrayList是否是线程安全的？" class="headerlink" title="ArrayList是否是线程安全的？"></a>ArrayList是否是线程安全的？</h3><p>非线程安全，如果需要线程安全，可以使用Vector或者CopyOnWriteList</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h3 id="HashSet是如何去重的"><a href="#HashSet是如何去重的" class="headerlink" title="HashSet是如何去重的?"></a>HashSet是如何去重的?</h3><p>HashSet底层是通过HashMap实现的，HashSet中的元素放在HashMap中的K上面，我们都知道HashMap中的K是不重复的，内容相同的对象hashCode是相同的(HashCode决定元素存储在HashMap中Entry数组中的位置)，并且如果equals方法返回对象是相同的话默认会覆盖Value内容，但其实这里对Hashset来讲value覆盖与否都无所谓(hashset中放入的是PRENSENT对象每次都一样)，因为关注的是hashmap中的k</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h3 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h3><ul>
<li>HashTable是线程安全的(所有方法被sychronized修饰)，HashMap不是</li>
<li>HashTable不允许有空的key和value，HashMap可以</li>
</ul>
<h3 id="HashMap是否是线程安全的-如果在多线程环境下并发访问会不会有问题？"><a href="#HashMap是否是线程安全的-如果在多线程环境下并发访问会不会有问题？" class="headerlink" title="HashMap是否是线程安全的?如果在多线程环境下并发访问会不会有问题？"></a>HashMap是否是线程安全的?如果在多线程环境下并发访问会不会有问题？</h3><p>HashMap不是线程安全的，jdk1.7的时候HashMap在多线程下并发增加元素扩容的时候会出现环形链表，导致死循环，jdk1.8的时候采用尾插法解决了环形链表的问题，不过还是非线程安全的</p>
<h3 id="HashMap底层是怎么实现的"><a href="#HashMap底层是怎么实现的" class="headerlink" title="HashMap底层是怎么实现的?"></a>HashMap底层是怎么实现的?</h3><p>HashMap在jdk1.7版本的时候是通过数组+链表的方式实现的,在jdk1.8里面引入了红黑树，在使用拉链法解决hash碰撞的时候，链中元素超过8的时候会转为红黑树</p>
<h3 id="红黑树和二叉排序树、AVL树的区别-延伸话题"><a href="#红黑树和二叉排序树、AVL树的区别-延伸话题" class="headerlink" title="红黑树和二叉排序树、AVL树的区别(延伸话题)"></a>红黑树和二叉排序树、AVL树的区别(延伸话题)</h3><p>二叉排序树</p>
<p>特点:</p>
<ul>
<li>若他的左子树不为空，则他的左子树上所有的值小于根节点的值</li>
<li>若他的右子树不为空，则它的右子树上所有的值大于根节点的值</li>
<li>它的左子树和右子树都是平衡二叉树</li>
<li>中序遍历二叉排序树可以得到一个正序有序的序列</li>
<li>通常情况下，操作时间复杂度为O(logn),极端情况下退化为O(n)</li>
</ul>
<p>这样的数据结构实际上是一个非常典型的适合进行二分法进行查找的结构，每当需要查找元素的时候，先跟根节点比较，就可以判断它在树的哪一端，每次查询都能够缩小一半的候选集，达到时间复杂度为O(logn),但是这里面有个问题，极端情况，如果二叉排序树插入的数据比较极端，比如插入了一组正序有序的数据，使得二叉排序树向右侧单侧倾斜，这时如果查找元素其实就相当于退化成了一个单链表，查找元素的时间复杂度退化为O(n),这种情况下实际上为了提高查找效率就引入了平衡二叉树和红黑树来使得二叉排序树构建的更加平衡。</p>
<p>平衡二叉树(AVL树、高度平衡树)<br>特点：</p>
<ul>
<li>是一种平衡二叉树</li>
<li>每一个节点的左子树和右子树的高度差的绝对值不会超过1<br>平衡二叉树是在构建二叉排序树的过程中，每插入或者删除一个节点，都会先检查是否破坏了树的平衡性，如果是，则找出最小的不平衡的树，通过右旋或者左旋，使之成为新的平衡树</li>
<li>平衡二叉树的插入、查找、删除的时间复杂度是O(logn)</li>
</ul>
<p>平衡二叉树追求的是全局平衡，在插入和删除的时候需要调整整棵树，显然这是很费时的，所以希望在调整的时候，不是整棵树进行结构性调整，而是局部性的调整，这样也就引出了红黑树</p>
<p>红黑树是一种二叉查找树，并在此基础上在每个节点上增加了一个存储位来表示节点的颜色，可以是红色或者黑色，通过对任何一条从根节点到叶子结点的路径的各节点着色方式的限制，确保红黑树没有任何一条路径多于其最短路径的两倍长，这保证了红黑树是大致平衡的，而且又不像平衡二叉树那样要求全局性的平衡</p>
<p>红黑树由以下约束保证了红黑树没有任何一条路径多于其最短路径的两倍长<br>特点：</p>
<ul>
<li>节点是红色或者黑色</li>
<li>根是黑色</li>
<li>所有叶子节点都是黑色</li>
<li>每个红色节点必须有两个黑色的子节点(从每个叶子到根节点的所有路径上不能有两个连续的红色节点)</li>
<li>从任一节点到其每个叶子节点的所有简单路径都包含相同数目的黑色节点</li>
</ul>
<p>在通过插入和删除时，会使得红黑树不再符合红黑树的性质，这时，需要少量(O(logn))的颜色变更和不超过三次的树旋转，牺牲了部分平衡性以换取插入删除时少量的旋转操作，整体性能优于AVL树</p>
<h3 id="ConcurrentHashMap是怎么实现的？"><a href="#ConcurrentHashMap是怎么实现的？" class="headerlink" title="ConcurrentHashMap是怎么实现的？"></a>ConcurrentHashMap是怎么实现的？</h3><h1 id="Java基础之关键字"><a href="#Java基础之关键字" class="headerlink" title="Java基础之关键字"></a>Java基础之关键字</h1><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>作用<br>final可以用来修饰类、方法、变量</p>
<p>修饰类的时候表示该类不能被继承<br>修饰方法的时候表示该方法在子类中不能被重写<br>修饰变量的时候，如果修饰的是基本数据类型，一旦被赋值就不能被再次赋值，如果是引用数据类型，只能保证引用所指向的地址不改变，而引用的对象的属性是可以改变的</p>
<h2 id="String为什么是不可变类-延伸问题"><a href="#String为什么是不可变类-延伸问题" class="headerlink" title="String为什么是不可变类(延伸问题)"></a>String为什么是不可变类(延伸问题)</h2><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h2 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h2><p>既然要聊接口和抽象类的区别，就得先聊一下接口和抽象类分别是什么，他们的共同点，然后再聊区别更容易理解一些。</p>
<p>抽象类概述:</p>
<p>当我们在设计一些行为和属性差不多的类的时候其实可以想到面向对象中的继承，用来抽取一个基类，既可以减少重复代码，又可以让代码变得简洁，抽象类的作用就是如此，用于抽取子类通用属性的一种类，只能用作父类，用于给子类继承并且不能够实例化，作为继承的模板，也是多态的一种表现形式<br>因此我们可以总 结下抽象类的特点</p>
<ul>
<li>不能被实例化，可以有构造函数</li>
<li>可以包含具体方法，也可以包含抽象方法(必须被子类(非抽象子类)实现)</li>
<li>可以包含成员变量和静态成员变量</li>
<li>子类的抽象方法不可以与父类的抽象方法同名</li>
</ul>
<p>接口概述:<br>接口是抽象方法的集合，如果某一个类实现了某个接口，那么他就必须实现这个接口的抽象方法，接口本身并不能做任何事情</p>
<p>接口的特点：</p>
<ul>
<li>接口中不能有构造方法</li>
<li>接口中可以定义”成员变量”,但是会自动转换为 public static final,即Java中的常量，并且必须被显式初始化</li>
<li>接口中的所有方法都是抽象方法，不能包含具体的方法，也不能包含静态的方法(jdk 8可以包含)</li>
<li>不可以通过new来实例化接口</li>
</ul>
<p>有了这些内容，我们就可以来回答接口和抽象类的区别了</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>默认的方法实现</td>
<td>可以有</td>
<td>jdk 8之后可以提供，之前不允许有</td>
</tr>
<tr>
<td>关键字</td>
<td>子类通过extends继承抽象类</td>
<td>子类通过implements实现接口</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象方法可以用public protected这些修饰符</td>
<td>接口方法默认public，不可以用其他修饰符</td>
</tr>
<tr>
<td>添加新方法</td>
<td>如果需要往抽象类中添加新的方法，可以提供默认的实现方法，不需要改变现有代码</td>
<td>jdk8以后可以提供默认方法，jdk8之前不可以，所以之前子类必须实现所有接口中的方法</td>
</tr>
<tr>
<td>构造方法</td>
<td>可以有</td>
<td>不可以有</td>
</tr>
<tr>
<td>设计理念</td>
<td>is-a的关系，是一种关系的延续</td>
<td>like-a的关系，体现的是一种功能扩展</td>
</tr>
</tbody></table>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>修饰成员变量  static可以用来修饰成员变量，也叫静态变量，在内存中只有一个副本，可通过类名访问<br>应用场景:<br>对象间传值</li>
</ul>
<ul>
<li>修饰方法   一般用来抽取工具方法，通过类名直接访问，不可以访问实例变量和实例方法。</li>
<li>修饰代码块  </li>
<li>静态内部类  </li>
<li>静态导入  写代码的时候可以导入某个类或者某个静态方法或静态变量，用来节省代码</li>
</ul>
<h2 id="sychronized怎么用的，里面是怎么实现的？"><a href="#sychronized怎么用的，里面是怎么实现的？" class="headerlink" title="sychronized怎么用的，里面是怎么实现的？"></a>sychronized怎么用的，里面是怎么实现的？</h2><h1 id="Java基础之数据结构"><a href="#Java基础之数据结构" class="headerlink" title="Java基础之数据结构"></a>Java基础之数据结构</h1><h1 id="Java基础之面向对象"><a href="#Java基础之面向对象" class="headerlink" title="Java基础之面向对象"></a>Java基础之面向对象</h1><h2 id="面向对象的特点或者说谈谈面向对象的理解？"><a href="#面向对象的特点或者说谈谈面向对象的理解？" class="headerlink" title="面向对象的特点或者说谈谈面向对象的理解？"></a>面向对象的特点或者说谈谈面向对象的理解？</h2><p>面向过程的特点是封装、继承、多态<br>聊到面向对象其实就不得不提面向过程，</p>
<p>面向过程是一种以事件为中心的变成思想，把解决问题的步骤分析出来，使用函数将这一个个步骤实现，使用的时候直接依次调用即可，简单的问题可以通过面向过程的思路来解决，直接有效，但是问题的规模很大时，面向过程的思想就不太够用了，慢慢的出现了面向对象的编程思想<br>而面向对象是一种以对象为核心的编程思想，把要解决的问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个对象在解决问题中步骤中的属性和行为。</p>
<p>面向过程和面向对象的优缺点:</p>
<p>面向过程:<br>优点：</p>
<ul>
<li>流程化，编程任务明确</li>
<li>效率高，面向过程强调代码的短小精悍，善于结合数据结构来开发高效率的程序<br>缺点：<br>需要深入思考，耗费精力，代码重用性差，扩展能力差，后期维护难度较大</li>
</ul>
<p>面向对象：<br>优点：</p>
<ul>
<li>结构清晰，模块化结构化，符合人类思维方式</li>
<li>易扩展，代码重用率高，可继承，可覆盖，可以设计出低耦合的系统</li>
<li>易维护，系统低耦合的特点有利于减少后期维护工作量<br>缺点：</li>
<li>开销大，修改更改对象内部时，对象的属性不允许直接存取，所以需要增加很多无意义，只负责读写的行为，使得编程工作增加负担，增加运行开销，程序变得臃肿</li>
</ul>
<h2 id="Java为什么不支持多继承"><a href="#Java为什么不支持多继承" class="headerlink" title="Java为什么不支持多继承"></a>Java为什么不支持多继承</h2><p>多继承会产生继承的二义性问题，比如B，C同时继承于A；D又多继承于B和C,这时候如果A中定义了一个f()方法，D到底是会调用谁呢？支持多继承的语言像C++是引入了虚继承来解决这个问题的，十分的晦涩难懂，Java的设计者在这里秉持着简单易用的原则，就把类的多继承给移除了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/05/07/about-knowledge-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/05/07/about-knowledge-tree/" itemprop="url">知识树的建立</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-07T19:03:10+08:00">
                2020-05-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天花了点时间把这段时间需要学习的内容列了一个思维导图，感觉之前的学习方式方法有问题，我们先对需要学习的内容列一个整体的知识体系，对自己有一个整体的把控之后，这时候再去某个细枝末节不断的去探索，去钻研，不至于学习漫无目的，毫无章法可言，以至于“东一榔头，西一棒槌”。</p>
<p><img src="https://s1.ax1x.com/2020/05/08/YmLbSx.png" alt></p>
<p>这个知识树会在后续的学习中不断的去扩充，复习的时候会对某一个节点进行系统的展开，持续更新中…</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/04/30/about-jvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/04/30/about-jvm/" itemprop="url">聊聊JVM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-30T11:07:09+08:00">
                2020-04-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在讲以下内容之前，我们先通过一个思维导图了解一下本文的大致内容</p>
<p>该图片引用自<a href="https://blog.csdn.net/sheep_3/article/details/51457116" target="_blank" rel="noopener">深入理解Java虚拟机总结-思维导图</a></p>
<p>————————————————<br><img src="https://s1.ax1x.com/2020/05/06/YAMRkq.png" alt></p>
<p><img src="https://s1.ax1x.com/2020/05/06/YAMdtP.png" alt></p>
<h2 id="内存区域划分"><a href="#内存区域划分" class="headerlink" title="内存区域划分"></a>内存区域划分</h2><p>这一部分我们主要来详细了解一下运行时数据区的内容</p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p><strong>特点</strong><br>线程私有区域，生命周期与线程相同</p>
<p><strong>作用</strong><br>Java虚拟机栈是描述的Java中方法执行的内存模型: 每个方法在执行的同时会创建一个栈帧(stack frame),用于存储<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法出口</strong>等信息。每一个方法调用至执行完成的时候，都对应着一个栈帧在虚拟机栈中从入栈到出栈的过程</p>
<p><strong>局部变量表</strong>存放了各种编译器可知的基本数据类型、引用数据类型和returnAddress指令(指向了下一条字节码指令的地址)，我们平时常说的栈指的就是Java虚拟机栈里面的局部变量表的内容</p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p><strong>特点</strong><br>线程私有区域<br><strong>概述</strong><br>程序计数器是一块较小的内存空间，可以看作是当前线程执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成</p>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈跟Java虚拟机栈的作用是类似的，他们的区别是Java虚拟机栈执行的是Java方法，而本地方法栈执行的是虚拟机用到的Native方法</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p><strong>特点</strong><br>所有线程共享区域，开发人员关注的核心区域，垃圾收集器管理的主要区域，Java虚拟机中内存最大的一块<br><strong>概述</strong><br>该内存区块是Java虚拟机中最大的一块内存区域，在虚拟机启动时创建，几乎所有的对象实例都会在这里进行分配，根据内存回收的角度来看，现在的大多数收集器大多采用分代收集算法，所以Java堆还可以进行进一步的细分:新生代和老年代，新生代再细致一点可分为Eden空间，from survivor空间，to survivor空间。</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p><strong>特点</strong><br>所有线程共享区域<br><strong>概述</strong><br>方法区与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。虽然虚拟机规范把方法区作为堆的一个逻辑部分，但他还有另外的一个别名叫非堆，目的就是和Java堆进行区分</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p><strong>概述</strong><br>运行时常量池是方法区中的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后进入方法区中的运行时常量池中存放</p>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁的使用，也可能导致OOM异常，在JDK1.4中新加入了NIO,引入了一种基于Channel与Buffer的I/O方式，它可以通过native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，在一些场景中能显著提升性能，因为避免了再Java堆和native堆上来回复制数据</p>
<h2 id="如何判断对象已死？"><a href="#如何判断对象已死？" class="headerlink" title="如何判断对象已死？"></a>如何判断对象已死？</h2><p>在Java堆里面几乎存放着Java世界中所有的对象实例，垃圾收集器在进行垃圾回收前，第一件事情就是需要判断哪些对象还“存活”着，哪些对象已经“死去”</p>
<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器就+1，引用失效时，计数器就-1，任何时刻计数器为0的对象即不再使用的对象，即可以理解为这个对象已经“死去”了，在下次进行垃圾回收的时候，就可以将这些对象收集。引用计数实现简单，判定效率也很高，但是他很难解决对象之间的相互循环引用的问题</p>
<h3 id="根搜索算法-可达性分析算法"><a href="#根搜索算法-可达性分析算法" class="headerlink" title="根搜索算法(可达性分析算法)"></a>根搜索算法(可达性分析算法)</h3><p>通过一系列的被称为<strong>GC Roots</strong>的对象作为起始点，从这些节点开始向下进行搜索，搜索所走过的路径为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明是对象不可用的。</p>
<p>哪些对象可以用来当做GC ROOTS呢？</p>
<ul>
<li>虚拟机栈中局部变量表中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用的对象</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="复制收集算法"><a href="#复制收集算法" class="headerlink" title="复制收集算法"></a>复制收集算法</h3><p><strong>缺点</strong></p>
<ul>
<li>可用内存大小变为原来的一半</li>
<li>如果对象存活率较高，会出现大量复制，效率会降低</li>
</ul>
<p>将可用内存按容量分为大小相等的两块，每次可使用其中的一块，当一块中的内存耗尽时，对这块内存区域进行垃圾收集，将这块内存中所有还存活的对象复制到另一块，再把这块的内存区域一次性清理掉，这样每次只对整个半区进行内存回收，分配的时候就不用了考虑内存碎片的问题了</p>
<h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p><strong>缺点</strong></p>
<ul>
<li>先标记，后清除，两阶段效率都不高</li>
<li>产生大量内存碎片</li>
</ul>
<p>先标记出所有需要回收的对象，标记完成后统一进行回收，后续的垃圾收集算法都是基于这种算法进行改进而得到的，缺点是标记和清除效率都不高，并且标记清除后会有大量的不连续的内存碎片</p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>与标记清除算法类似，但是不是直接清除，而是将所有可存活的对象向一端移动，然后直接清理掉边界外的内存。</p>
<h3 id="新生代对象特点"><a href="#新生代对象特点" class="headerlink" title="新生代对象特点"></a>新生代对象特点</h3><p>大部分情况都是朝生夕死</p>
<h3 id="老年代对象特点"><a href="#老年代对象特点" class="headerlink" title="老年代对象特点"></a>老年代对象特点</h3><p>对象存活率较高，没有额外空间进行分配担保</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体表现。</p>
<h3 id="Serial垃圾收集器"><a href="#Serial垃圾收集器" class="headerlink" title="Serial垃圾收集器"></a>Serial垃圾收集器</h3><p><strong>特点</strong></p>
<ul>
<li>单线程收集</li>
<li>新生代收集器</li>
<li>收集时停止所有工作线程的工作(STOP THE WORLD)</li>
<li>跟其他垃圾收集器相比简单而高效(单个CPU环境下，不存在线程上下文切换的开销，可以获得最高的单线程收集效率)</li>
<li>client模式下新生代默认垃圾收集器</li>
</ul>
<p>Serial收集器是最基本发展最悠久的垃圾收集器，曾经(JDK1.3.1之前)是虚拟机新生代的收集的唯一选择，看名字就可以看出来，这个收集器是一个单线程的收集器，但他的单线程不仅仅体现在它只会使用一个垃圾回收线程去完成垃圾回收工作，更重要的是，在进行垃圾回收的时候必须暂停其他所有的工作线程，直至收集结束。这项工作实际上是虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。</p>
<p><img src="https://pic.yupoo.com/crowhawk/6b90388c/6c281cf0.png" alt><br>Serial/Serial Old垃圾收集器运行示意图</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p><strong>特点</strong></p>
<ul>
<li>新生代收集器</li>
<li>Serial收集器的多线程版本</li>
<li>许多运行在server模式下的虚拟机中首选的新生代收集器</li>
</ul>
<p>ParNew收集器实际上就是Serial收集器的多线程版本，除了使用多条线程进行垃圾手机外，其余的控制参数、垃圾收集算法，Stop The World、对象分配规则、回收策略都跟Serial垃圾收集器完全一样。许多运行在server模式下的虚拟机中首选的新生代收集器，除了Serial外，只有Parnew能配合CMS垃圾收集器工作，单CPU场景下，不会比Serial收集器有更好的效果(存在线程切换的开销)，</p>
<p><img src="https://pic.yupoo.com/crowhawk/605f57b5/75122b84.png" alt><br>ParNew 收集器运行示意图</p>
<h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p><strong>特点</strong></p>
<ul>
<li>新生代收集器</li>
<li>使用复制算法，多线程收集</li>
<li>关注点与其他收集器不同，关注的是达到一个可控制的吞吐量</li>
</ul>
<p>Parallel Scavenge收集器的特点是他关注的是可控制的吞吐量，即CPU运行用户代码的时间/(CPU运行用户代码时间+ 垃圾收集时间)，举例来说，虚拟机运行100分钟，垃圾收集时间为1分钟，那吞吐量就是99%，该收集器提供了两个参数用于精准控制吞吐量，分别是控制最大垃圾收集时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数</p>
<p>MaxGCPauseMillis 是一个大于0的毫秒数，当然并不是设置的越小越好，GC停顿时间的缩短是以牺牲吞吐量和新生代空间来换取的: 比如把新生代调小，收集300M的新生代肯定比500M要快，这会导致垃圾收集会变得比之前更频繁, 举个例子 原来10秒收集一次，每次停顿100毫秒，现在每5秒收集一次，每次停顿70毫秒，停顿时间是缩小了，但是吞吐量也下来了</p>
<p>吞吐量 = CPU运行用户代码的时间/(CPU运行用户代码时间+ 垃圾收集时间)<br>GCTimeRatio 相当于 1 / 吞吐量</p>
<h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial-Old 收集器"></a>Serial-Old 收集器</h3><p><strong>特点</strong></p>
<ul>
<li>老年代收集器</li>
<li>单线程，回收时暂停所有用户线程</li>
<li>使用标记-整理算法</li>
</ul>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p><strong>特点</strong></p>
<ul>
<li>老年代收集器</li>
<li>Parallel Scanvenge的老年代版本，使用多线程</li>
<li>使用标记-整理算法</li>
</ul>
<h3 id="CMS垃圾收集器"><a href="#CMS垃圾收集器" class="headerlink" title="CMS垃圾收集器"></a>CMS垃圾收集器</h3><p><strong>特点</strong></p>
<ul>
<li>老年代收集器</li>
<li>采用标记-清除算法</li>
<li>并发收集，低停顿</li>
<li>CMS MinorGC时会暂停所有的用户线程，并以多线程的方式进行垃圾回收。FullGC时不再暂停应用线程，而是使用若干个后台进程定期的对老年代空间进行扫描，及时回收不再使用的对象</li>
</ul>
<p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的垃圾收集器,很大一部分Java应用集中在互联网网站和B/S系统的服务端上，这类应用重视服务的响应速度，希望系统停顿时间较短，CMS就比较符合这类应用的需求</p>
<h4 id="垃圾收集过程"><a href="#垃圾收集过程" class="headerlink" title="垃圾收集过程"></a>垃圾收集过程</h4><ul>
<li>初始标记 标记GCRoots 能直接关联的对象，速度很快 暂停所有用户线程 </li>
<li>并发标记  进行GCRoots Tracing的过程</li>
<li>重新标记  修正并发标记期间 因用户程序继续工作导致标记产生变动的那一部分对象的标记记录，停顿时间比初始标记时间稍长一些，远比并发标记时间短 暂停所有用户线程</li>
<li>并发清除</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>因为使用标记-清除算法，易产生大量内存碎片，内存碎片较多时，将会给分配大对象带来很大麻烦 可以通过开启FullGC时候进行内存整理，但是会延长停顿时间</li>
<li>CMS收集器无法处理浮动垃圾，可能出现Concurrent Mode Failure而导致另一次的FullGC产生</li>
<li>对CPU资源敏感</li>
</ul>
<p>浮动垃圾: 并发清除阶段，垃圾收集线程和用户线程并行执行，伴随着程序的运行，就会不断有垃圾产生，这些新产生的垃圾在标记过程之后产生，CMS无法在当次垃圾收集进行</p>
<p><img src="https://pic.yupoo.com/crowhawk/fffcf9a2/f60599b2.png" alt><br>CMS收集器运行示意图</p>
<h3 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h3><p>G1的主要关注点在于达到可控的停顿时间，在这个基础上尽可能提高吞吐量，G1被设计用来长期取代CMS垃圾收集器，和CMS的相同点在于都属于并发收集器，大部分收集阶段都不需要挂起应用程序。区别在于G1没有CMS的碎片化问题，同时提供更加可控的停顿时间</p>
<p>G1将整个堆划分为一个个大小相等的小块，每一块的内存是连续的。和分代算法一样，G1中每个块也会充当Eden,Survivor,Old角色，但是他们不是固定的，这使得内存使用更加灵活</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>引入分区概念</li>
<li>合理利用垃圾收集各个周期的资源，解决了CMS及其他收集器的缺陷</li>
<li>使用标记-整理算法</li>
</ul>
<h4 id="对比CMS"><a href="#对比CMS" class="headerlink" title="对比CMS"></a>对比CMS</h4><ul>
<li>不再基于标记-清除算法，不会产生内存碎片</li>
<li>停顿时间可控 G1可以通过设置预期停顿时间来控制垃圾收集时间来避免应用雪崩现象</li>
<li>并行与并发 G1 能够充分的利用CPU，多核环境下的硬件优势来缩短STW的停顿时间</li>
</ul>
<h4 id="垃圾大致收集过程"><a href="#垃圾大致收集过程" class="headerlink" title="垃圾大致收集过程"></a>垃圾大致收集过程</h4><ul>
<li>新生代垃圾收集</li>
<li>并发收集，和用户线程同时执行</li>
<li>混合垃圾收集</li>
<li>必要的时候FullGC</li>
</ul>
<h5 id="G1的堆结构"><a href="#G1的堆结构" class="headerlink" title="G1的堆结构"></a>G1的堆结构</h5><p>传统的GC收集器将内存空间划分为新生代老年代和永久代(JDK1.8去除了永久代，引入了元空间metaspace)，这种划分的特点是各代的存储地址是连续的，而在G1收集器中则引入了分区的概念，弱化了分代的概念。</p>
<ol>
<li>整个堆默认分为2048份均分，每块大小是一致的(1M-32M)</li>
<li>逻辑上，也会分为Eden,Survivor,Old区，但是各个区的大小是不固定的</li>
<li>未分配区域可以为任何一个代使用</li>
</ol>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>服务器多核CPU,JVM所占内存较大的情况(至少大于4G)</li>
<li>应用在运行过程中会产生大量内存碎片，需要经常压缩空间</li>
<li>想要更可控，可预期的GC停顿周期，防止高并发下应用雪崩现象</li>
</ul>
<h2 id="内存分配与垃圾回收策略"><a href="#内存分配与垃圾回收策略" class="headerlink" title="内存分配与垃圾回收策略"></a>内存分配与垃圾回收策略</h2><p>未完待续<del>~</del></p>
<hr>
<h2 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h2><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>《深入理解Java虚拟机》 第2版</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/04/23/about-spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/04/23/about-spring/" itemprop="url">聊聊Spring框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-23T14:05:34+08:00">
                2020-04-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在工作和面试中，Spring作为一个高频出现的框架，不能只是会用，还要对他有一定深入的了解，这样出现问题或者别人跟你交流起Spring的内容的时候，不至于哑口无言，今天我们就来聊聊Spring中我们必须要知道或者掌握的内容</p>
<h1 id="IOC-和AOP"><a href="#IOC-和AOP" class="headerlink" title="IOC 和AOP"></a>IOC 和AOP</h1><p>可以说IOC和AOP是Spring的灵魂，我们无时无刻不在用这两个特性，下面就来讲讲IOC和AOP分别都是什么</p>
<h2 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h2><p>IOC(Inversion of Controll)控制反转，什么是控制反转呢？原来需要开发者手动创建对象，现在这个过程交给Spring容器，Spring预先把对象创建好，你需要的时候声明一个属性直接给注入进来，这样把原来创建对象的控制权给反转过来，就叫控制反转，那在这里我们反转的是什么内容呢？实际上这里我们反转的是获取依赖对象的过程，这样其实IOC其实还有另外一个名字，叫依赖注入，这实际上就是Spring来实现IOC的方式，通过提供一个IOC容器，在容器运行期间，利用依赖关系动态地将某种依赖关系注入到对象中。这样的好处就是最大的程度实现对象之间的解耦合。</p>
<p>比如我有一块业务，分别交给了三个人来实现这一块业务中的三个部分，那么只有这三个人的功能组合到一起才能实现这一块业务，那么每个人都必须要清楚自己的那部分业务什么时候要依赖对方的那一部分的业务，什么时候产生交互，这样沟通成本就很高，每个人都要做一次业务串线的操作，而不是专心于自己的业务，那这个时候，假如我们能引入第4个人，由第4个人来负责怎么样组合起这3个人的业务，什么时候交互，那么这三个人就完全不用处理和其他人之间的业务对接，完全专心于自己那一部分的业务开发了，这其实跟SpringIOC容器的思想就是类似的。</p>
<h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">面向切面的程序设计是计算机科学中的一种程序设计思想，旨在将横切关注点与业务主体进行进一步分离，  </span><br><span class="line">以提高代码模块化的程度。通过在现有代码基础上增加额外的通知机制，能够对被声明为切点(pointcut)  </span><br><span class="line">的代码进行统一的管理和装饰，如对所有‘set*’开头的方法都加上后台日志。该思想能够使得开发人员能够将  </span><br><span class="line">与代码核心业务并不是那么密切相关的功能添加至程序中，同时又不降低业务代码的可读性，面向切面的程序  </span><br><span class="line">设计是面向切面开发的基础   ---摘自WIKIPEDIA</span><br></pre></td></tr></table></figure>

<p>看了维基百科上面的这么长的一段话，想必头都大了，那么到底AOP是什么呢，其实这是一种思想，一种将核心逻辑与边缘逻辑拆分的思想，我们把我们的一块业务进行拆分，把业务强相关的逻辑称为核心逻辑，将不是特别相关的业务逻辑称为边缘逻辑，那么AOP就是把核心逻辑作为关注点，将非核心逻辑也就是边缘逻辑从原有代码剥离出来，形成一个个的切面，在我们的关注点(核心逻辑)前后的连接点插入一系列的切面，将核心逻辑和边缘逻辑通过这种方式编织起来的过程就叫做AOP。这样的好处就是有一些重复的工作像事务管理、日志管理、权限控制等功能封装起来，减少重复代码，并降低模块间的耦合度，有利于系统的拓展性和可维护性。</p>
<h2 id="AOP中的几个重要概念"><a href="#AOP中的几个重要概念" class="headerlink" title="AOP中的几个重要概念"></a>AOP中的几个重要概念</h2><h3 id="Advice"><a href="#Advice" class="headerlink" title="Advice"></a>Advice</h3><p>切面的工作被称为通知，通知定义了切面是什么以及何时使用，除了描述切面的工作外，通知还解决了何时执行这个工作</p>
<h3 id="JoinPoint-连接点"><a href="#JoinPoint-连接点" class="headerlink" title="JoinPoint 连接点"></a>JoinPoint 连接点</h3><p>连接点是指应用执行过程中可以插入切面的一个点</p>
<h3 id="PointCut-切点"><a href="#PointCut-切点" class="headerlink" title="PointCut 切点"></a>PointCut 切点</h3><p>一个切面并不需要通知应用所有的连接点，切点有助于缩小切面通知的连接点范围，通知中定义了切面的“什么”和“何时”，而切点则定义了“何处”</p>
<h3 id="Aspect-切面"><a href="#Aspect-切面" class="headerlink" title="Aspect 切面"></a>Aspect 切面</h3><p>切面是通知和切点的集合，通知和切点定义了切面的全部内容，它们是什么，在何时何处完成其功能</p>
<h3 id="Introduction-引入"><a href="#Introduction-引入" class="headerlink" title="Introduction 引入"></a>Introduction 引入</h3><p>Introduction允许我们向现有的类添加新方法和属性</p>
<h3 id="weaving-织入"><a href="#weaving-织入" class="headerlink" title="weaving 织入"></a>weaving 织入</h3><p>织入是将切面应用到目标对象并创建新的代理对象的过程，切面在指定的连接点被织入到目标对象中。在目标对象的生命周期中有很多个点进行织入</p>
<ul>
<li>编译期 切面在目标类编译时被织入。这种方式需要特殊的编译器，AspectJ的织入编译器就是以这种方式织入切面的</li>
<li>类加载期 切面在目标类加载到JVM时候被织入，这种方式需要特殊的类加载器，它可以在目标类被引入到应用程序之前，增强该目标类的字节码。AspectJ 5就支持这种方式织入切面</li>
<li>运行期 切面在应用运行的某个时刻被织入。一般情况下，在织入切面时候AOP容器会为目标对象动态的创建一个代理对象。SpringAOP就是以这种方式织入切面的。</li>
</ul>
<h2 id="Spring-AOP原理"><a href="#Spring-AOP原理" class="headerlink" title="Spring AOP原理"></a>Spring AOP原理</h2><p>Spring是在运行时通知对象，通过在代理类中包裹切面，Spring在运行期间把切面织入到Spring管理的Bean中。如下图所示，代理类封装了目标类，并拦被通知方法的调用，再把调用转发给真正的目标bean.当代理拦截到方法调用的时候，在调用bean方法之前，会执行切面逻辑。</p>
<p>Spring在运行时创建代理对象，代理勒种包裹了切面和目标对象，并拦截被通知方法的调用，在执行bean方法之前或之后执行切面逻辑，之后再将请求转发给目标对象</p>
<p><img src="https://img-blog.csdn.net/20160505123413155" alt><br>图片引用自<a href="https://blog.csdn.net/github_34889651/article/details/51321499" target="_blank" rel="noopener">Spring AOP 之 通知、连接点、切点、切面</a><br>直到应用需要用到被代理的bean时，spring才会创建代理对象，如果是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器就能织入AOP切面</p>
<h1 id="Spring-IOC怎么实现的？"><a href="#Spring-IOC怎么实现的？" class="headerlink" title="Spring IOC怎么实现的？"></a>Spring IOC怎么实现的？</h1><p>IOC实际上是通过在Spring内部持有一个beanfactory 在Spring容器启动的时候将被加上注解的类加载到容器中，当你在使用bean的时候去管Spring的容器拿的一个过程</p>
<h1 id="动态代理和静态代理"><a href="#动态代理和静态代理" class="headerlink" title="动态代理和静态代理"></a>动态代理和静态代理</h1><p>要讲动态代理和静态代理，实际上要先从代理模式说起，什么是代理模式呢？代理模式提供了对目标对象的额外访问方式，即通过代理对象访问目标对象这样可以在不修改目标对象的前提下、提供额外的功能操作，扩展目标对象的功能。说完了什么是代理模式，那么静态代理和动态代理分别是什么呢？其实静态代理还是动态代理是从代理类创建的时间节点来看的，静态代理是在程序运行期前，代理类已经存在了(通过developer由ide编写源代码后，对其编译)，而动态代理是在程序运行期间才会创建相应的代理类，也就是每需要使用静态代理来对目标对象进行增强的时候，就需要创建一个目标对象的代理类，这样就可能带来很多的代理类</p>
<p>静态代理中的角色</p>
<ol>
<li>subject抽象主题类，定义了代理对象和真实对象共同的接口方法，既可以是接口又可以是抽象类</li>
<li>real subject 真实主题类，也就是被委托类或被代理类，该类定义了代理对象表示的真实对象，实现了subject接口，client通过代理对象间接地调用真实主题类中的方法，由real subject来执行真正的业务逻辑</li>
<li>proxy subject 代理类，该类也被称为委托类或代理类，该类中持有一个真实主题类的引用，实现了subject接口，在其实现的接口方法中调用真实主题类中对应的接口方法，起到代理的作用</li>
<li>client 客户端，使用代理</li>
</ol>
<h1 id="spring中bean的生命周期"><a href="#spring中bean的生命周期" class="headerlink" title="spring中bean的生命周期"></a>spring中bean的生命周期</h1><ol>
<li>实例化bean实例及</li>
<li>按照spring上下文对实例化的bean设置对象属性(也就是进行IOC注入)</li>
<li>如果这个bean实现了BeanNameAware接口，会调用它实现的setBeanName方法，此处传递的就是spring配置文件中id的值</li>
<li>BeanPostProcessor前置处理</li>
<li>是否实现InitialBean接口</li>
<li>是否配置自定义的init-method</li>
<li>BeanPostProcessor后置处理</li>
<li>注册</li>
</ol>
<p><img src="https://images0.cnblogs.com/i/580631/201405/181453414212066.png" alt><br><img src="https://images0.cnblogs.com/i/580631/201405/181454040628981.png" alt></p>
<h1 id="Spring的启动流程"><a href="#Spring的启动流程" class="headerlink" title="Spring的启动流程"></a>Spring的启动流程</h1><h2 id="applicationContext继承体系"><a href="#applicationContext继承体系" class="headerlink" title="applicationContext继承体系"></a>applicationContext继承体系</h2><p><img src="https://s1.ax1x.com/2020/04/25/JsJCgH.png" alt></p>
<h2 id="通过SpringApplication-run启动主类"><a href="#通过SpringApplication-run启动主类" class="headerlink" title="通过SpringApplication.run启动主类"></a>通过SpringApplication.run启动主类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//启动一个计时器,记录应用启动花费的时间()</span></span><br><span class="line">      StopWatch stopWatch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">stopWatch.start();</span><br><span class="line">ConfigurableApplicationContext context = <span class="keyword">null</span>;</span><br><span class="line">FailureAnalyzers analyzers = <span class="keyword">null</span>;</span><br><span class="line">configureHeadlessProperty();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">SpringApplicationRunListeners listeners = getRunListeners(args);</span><br><span class="line">listeners.starting();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">//封装命令行启动应用时的参数</span></span><br><span class="line">	ApplicationArguments applicationArguments = <span class="keyword">new</span> DefaultApplicationArguments(</span><br><span class="line">			args);</span><br><span class="line">	<span class="comment">//1.准备应用运行时环境，</span></span><br><span class="line">	<span class="comment">//2.加载外部配置文件(发布ApplicationEnvironmentPreparedEvent，SpringApplicationRunListeners监听到后，分发给下面的listeners,ConfigFileApplicationListener收到事件后去各个目录扫配置文件(xml,yaml,properties))</span></span><br><span class="line">	<span class="comment">//3.发布ApplicationEnvironmentPreparedEvent </span></span><br><span class="line">	ConfigurableEnvironment environment = prepareEnvironment(listeners,</span><br><span class="line">			applicationArguments);</span><br><span class="line">	<span class="comment">//打印启动banner图</span></span><br><span class="line">	Banner printedBanner = printBanner(environment);</span><br><span class="line">	<span class="comment">//创建ConfigurableEnvironment的实例(反射)，即创建IOC容器</span></span><br><span class="line">	context = createApplicationContext();</span><br><span class="line">	analyzers = <span class="keyword">new</span> FailureAnalyzers(context);</span><br><span class="line">	<span class="comment">//容器刷新前调用，允许对容器做进一步的设置和处理</span></span><br><span class="line">	prepareContext(context, environment, listeners, applicationArguments,</span><br><span class="line">			printedBanner);</span><br><span class="line">	refreshContext(context);</span><br><span class="line">	afterRefresh(context, applicationArguments);</span><br><span class="line">	<span class="comment">//容器启动完成，通知关注的listeners(发布ApplicationReadyEvent)</span></span><br><span class="line">	listeners.finished(context, <span class="keyword">null</span>);</span><br><span class="line">	<span class="comment">//计时器停止计时，打印启动所花费的时间</span></span><br><span class="line">	stopWatch.stop();</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span>.logStartupInfo) &#123;</span><br><span class="line">		<span class="keyword">new</span> StartupInfoLogger(<span class="keyword">this</span>.mainApplicationClass)</span><br><span class="line">				.logStarted(getApplicationLog(), stopWatch);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">	handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="refreshContext"><a href="#refreshContext" class="headerlink" title="refreshContext"></a>refreshContext</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置启动时间，启动标志，移除所有类元数据缓存，准备刷新时的应用上下文</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"><span class="comment">//告子类刷新内部beanFactory</span></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line"><span class="comment">//准备在此上下文中使用的beanfatory(设置classloader和postProcessors,注册环境以及系统变量bean)</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">	postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">	invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">	<span class="comment">//注册bean后置处理器</span></span><br><span class="line">	registerBeanPostProcessors(beanFactory);</span><br><span class="line">	<span class="comment">//做国际化处理i18n</span></span><br><span class="line">	<span class="comment">// Initialize message source for this context.</span></span><br><span class="line">	initMessageSource();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">	initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">	onRefresh();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">	registerListeners();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">	<span class="comment">//初始化剩余的所有单例bean</span></span><br><span class="line">	finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">	<span class="comment">//完成容器初始化，发布容器刷新完成事件</span></span><br><span class="line">	finishRefresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Spring和SpringBoot的区别"><a href="#Spring和SpringBoot的区别" class="headerlink" title="Spring和SpringBoot的区别"></a>Spring和SpringBoot的区别</h1><ul>
<li>SpringBoot内嵌了tomcat容器，不用再使用独立的web容器</li>
<li>SpringBoot相对于Spring来说，使用约定由于配置的原则，不在通过以前那种大量的xml配置和引入一大堆依赖，大大简化了开发人员的工作</li>
<li>可以实现自动装配</li>
</ul>
<h1 id="Spring-Cloud中用过哪些组件"><a href="#Spring-Cloud中用过哪些组件" class="headerlink" title="Spring Cloud中用过哪些组件"></a>Spring Cloud中用过哪些组件</h1><p>注册中心  配置中心  网关 </p>
<h1 id="eureka、zookeeper做注册中心有什么区别"><a href="#eureka、zookeeper做注册中心有什么区别" class="headerlink" title="eureka、zookeeper做注册中心有什么区别"></a>eureka、zookeeper做注册中心有什么区别</h1><h1 id="feign是如何保证负载均衡和熔断策略的"><a href="#feign是如何保证负载均衡和熔断策略的" class="headerlink" title="feign是如何保证负载均衡和熔断策略的"></a>feign是如何保证负载均衡和熔断策略的</h1>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/04/20/about-cache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/04/20/about-cache/" itemprop="url">谈谈缓存</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-20T12:08:54+08:00">
                2020-04-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前文章提到过，redis的常见使用场景之一就是缓存，那么既然聊到缓存，那么肯定会聊到缓存和数据库双写一致性的问题，今天就来聊聊缓存跟数据库双写一致性的问题</p>
<h1 id="缓存双写一致性问题"><a href="#缓存双写一致性问题" class="headerlink" title="缓存双写一致性问题"></a>缓存双写一致性问题</h1><p>只要系统用缓存，就可能涉及到缓存和数据库双写，只要设计到双写，就可能存在一致性问题</p>
<h2 id="缓存更新的策略"><a href="#缓存更新的策略" class="headerlink" title="缓存更新的策略"></a>缓存更新的策略</h2><h3 id="先删除缓存，再更新数据库"><a href="#先删除缓存，再更新数据库" class="headerlink" title="先删除缓存，再更新数据库"></a>先删除缓存，再更新数据库</h3><h4 id="为什么是删除缓存而不是更新缓存？"><a href="#为什么是删除缓存而不是更新缓存？" class="headerlink" title="为什么是删除缓存而不是更新缓存？"></a>为什么是删除缓存而不是更新缓存？</h4><ul>
<li><p><strong>缓存更新的代价可能比较高，数据更新如果不是热点数据存在资源浪费</strong><br>写多读少的场景，缓存根本没有被读到，反而进行了大量的更新，浪费性能<br>写入数据库的值不是直接写入缓存，而是还需要进行一些计算，每次写完数据库再进行一些计算，浪费性能，相比之下，删除缓存反而比较适合</p>
</li>
<li><p>存在脏数据问题,并发更新缓存<br>A,B同时更新一条缓存，B先更新完的，A再执行就把B更新过来的数据给覆盖掉了</p>
</li>
</ul>
<p>再回到先删除缓存再更新数据库这里，也存在数据不一致的情况</p>
<p>场景：请求A进行更新操作，请求B进行查询操作</p>
<p>1） 请求A进行写操作，删除缓存<br>2）请求B进行读操作,查询缓存发现缓存不存在<br>3）请求B查询数据库，将数据库中的旧值<br>4）请求B将旧值写入缓存<br>5) 请求A将新值写入数据库</p>
<p>如果不设置过期时间，请求B写入的脏数据就会一直存在，这种问题如何解决呢？<br>可以通过延时双删策略,如下述所示</p>
<p>1）删除缓存<br>2）更新数据库<br>3）延时等待(等待刚才的读请求完成操作)<br>4）再次删除缓存</p>
<p>这个延时的时间需要自行评估自己项目中读请求B的操作时间，并在读请求B的耗时上+几百毫秒来确保读请求结束</p>
<p>这种延时会降低吞吐量，怎么办？<br>将第二次删除改为异步删除，写请求更新完数据库直接返回，不必再延时等待了</p>
<p>如果第二次删除失败了，怎么办？</p>
<p>提供保障机制:删除重试策略</p>
<h3 id="先更新数据库，再删除缓存"><a href="#先更新数据库，再删除缓存" class="headerlink" title="先更新数据库，再删除缓存"></a>先更新数据库，再删除缓存</h3><p>这种方案又名为《cache-aside pattern》</p>
<ul>
<li>读的时候，先读缓存，缓存中如果没有再读数据库，然后取出后放入缓存，同时返回响应</li>
<li>更新的时候，先更新数据库，再删除缓存</li>
</ul>
<p>这里实际上是应用了一种懒加载的思路，什么时候用，什么时候再去计算缓存</p>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p>有可能存在脏数据问题</p>
<ul>
<li>并发读写</li>
</ul>
<ol>
<li>缓存刚好失效</li>
<li>请求A过来查询缓存，发现没有查询数据库得到一个旧值</li>
<li>请求B更新数据库</li>
<li>请求B删除缓存</li>
<li>请求A将查到的旧值更新到缓存中</li>
</ol>
<p>这种情况要求3中写操作比2中读操作要快，才有可能导致4比5要快，但是一般来说数据库读的远快于数据库的写操作，因此这一情形比较难出现，但不是不会出现，那么如果出现了这种问题要如何解决呢？</p>
<ul>
<li>设置缓存的有效期</li>
<li>在请求B更新完数据库后，采用异步延时删除的策略，并确保此时没有操作这一缓存的读请求后再删除缓存</li>
</ul>
<hr>
<ul>
<li>删除缓存失败导致脏数据</li>
</ul>
<p>一个写操作将新值写入数据库，然后删除缓存时失败，(无论先删缓存还是后删缓存都会存在这个问题)导致缓存数据库数据不一致</p>
<p>解决方案: 提供一个保障重试的机制即可，确保最终缓存被清除</p>
<h1 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a>缓存雪崩问题</h1><p> 简介
Redis服务重启或者宕机，或者大量缓存在同一时刻失效，此时大量的请求全部打到DB上，DB有可能扛不住从而导致宕机
</p>

<p>解决方案: </p>
<ul>
<li>给每个缓存设置不同的失效时间(比如用当前时间+随机时间段)，避免大量缓存在同一时间失效</li>
<li>如果是集群部署，将热点数据均匀分布在不同的redis节点上也能避免全部失效的问题，或者热点数据压根就不设置过期时间</li>
</ul>
<h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>简介
要查询的数据在缓存和数据库内都不存在，用户不断用这样的数据发起请求，导致数据库压力激增，严重时候可能拖垮数据库
</p>

<p>解决方案: </p>
<ol>
<li>接口层增加校验，用户添加鉴权，接口参数做校验，不合法参数直接返回，缓存和数据库中都取不到的数据，也可以将对应的key value(置为null)缓存起来，过期时间设置短一点，这样可以保证同一个用户无法反复用一个数据暴力攻击</li>
<li>可以使用布隆过滤器</li>
</ol>
<h1 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h1><p>
缓存击穿其实跟缓存雪崩有点类似，只不过缓存击穿是指单个key值非常热点，在不停的接收并发，当这个key失效的瞬间持续的并发将缓存击穿，流量直接打到DB上面
</p>

<p>解决方案:</p>
<ul>
<li>设置热点数据永不过期</li>
<li>查缓存时候没有拿到去数据库查询，更新缓存的这一步加上互斥锁，拿不到的读请求需要进行一个自旋，等一会儿再去拿数据，拿到互斥锁的请求将数据更新到缓存后，后续的请求全都自旋完毕后直接从缓存中拿数据了，相当于给缓存“续了个费”</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.cnblogs.com/rjzheng/p/9041659.html" target="_blank" rel="noopener">分布式之数据库和缓存双写一致性方案解析</a><br><a href="https://juejin.im/post/5dbef8306fb9a0203f6fa3e2" target="_blank" rel="noopener">《我们一起进大厂》系列-缓存雪崩、击穿、穿透</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/04/20/about-redis-durability/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/04/20/about-redis-durability/" itemprop="url">谈谈redis中的持久化机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-20T12:07:33+08:00">
                2020-04-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="为什么要进行持久化"><a href="#为什么要进行持久化" class="headerlink" title="为什么要进行持久化"></a>为什么要进行持久化</h1><p>为了避免数据丢失</p>
<p>
redis作为一个键值对的内存数据库，数据全存储在内存当中，当遇到进程退出或者服务器重启宕机的情况，内存中的数据就会消失，那这样存在redis中的数据就全丢了，如果业务场景仅仅是缓存，数据丢失影响或许不大，重新去数据库加载下再次写入redis就行了，但是如果把业务数据存储在redis中，拿redis当数据库使用的话，数据的丢失可能是毁灭性的打击，所以为了避免数据丢失，redis提供了持久化的支持，可以选择不同的方式将数据从内存保存到磁盘上面，使数据可以持久化保存。
</p>

<h1 id="redis持久化机制"><a href="#redis持久化机制" class="headerlink" title="redis持久化机制"></a>redis持久化机制</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB 是一种快照存储持久化方式，持久化的时候fork一个子进程，通过COW机制生成RDB文件保证持久化</p>
<p>具体就是将某一时刻的内存数据保存为一个快照存储到磁盘中，默认文件名为dump.rdb,在redis服务启动的时候会将dump.rdb文件加载到内存中恢复数据。</p>
<h3 id="RDB触发条件"><a href="#RDB触发条件" class="headerlink" title="RDB触发条件"></a>RDB触发条件</h3><h4 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h4><p>通过在redis服务上面执行以下命令触发</p>
<ul>
<li>save 阻塞当前redis服务，执行save期间，redis服务不能处理其他命令，直到RDB过程完成为止，线上环境不建议使用</li>
<li>bgsave 执行该命令时，redis会在后台异步进行快照操作，此时redis服务仍然可以响应客户端请求。<br>具体操作是执行该命令时，redis会执行fork操作创建一个子进程，由子进程来负责RDB持久化过程，完成后自动结束。这里需要注意的是在fork的时候需要阻塞主进程，一般时间比较短，但是如果redis服务中的数据量比较大的话，fork时间就会变长，且占用内存会加倍。</li>
</ul>
<h4 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h4><p>自动触发是通过redis.conf配置自动触发 通过save “”来停用自动触发RDB</p>
<p>主从同步时，从节点向主节点发起同步请求，主节点收到sync命令后，开始执行bgsave</p>
<p>etc: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save 60 1 60s内如果 &gt;= 1个key值发生变化则会触发RDB</span><br><span class="line">save 600 10 600s内如果 &gt;= 10个key值发生变化会触发RDB</span><br></pre></td></tr></table></figure>

<h3 id="bgsave流程"><a href="#bgsave流程" class="headerlink" title="bgsave流程"></a>bgsave流程</h3><ol>
<li>查看是否正在进行RDB或者AOF持久化，是则直接返回</li>
<li>当前不在进行持久化，fork子进程，子进程和父进程共享内存数据，父进程发生新的写入操作时，会对影响的数据拷贝一个新的内存段(<strong>存在疑问</strong>)，在新的内存段上面进行处理，不影响子进程的数据</li>
<li>子进程将数据集写入到一个临时的RDB文件中</li>
<li>子进程对临时RDB文件写入完成后，用新的RDB文件替换老的RDB文件，并删除旧的RDB文件，并通过信号通知父进程</li>
</ol>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>AOF(Append Only File)是指把每次执行的写命令追加写入到日志中，当需要恢复数据的时候重新执行AOF中的命令就行了。实际上redis每次写入并没有直接写入到日志文件里，而是写入到一个缓冲区(aof_buf)中，而后通过缓冲区同步策略对缓冲区的数据进行落盘操作</p>
<h3 id="AOF执行流程"><a href="#AOF执行流程" class="headerlink" title="AOF执行流程"></a>AOF执行流程</h3><p>AOF不需要设置任何触发条件，对redis服务的所有写命令都会记录到AOF文件中</p>
<p>AOF的写入流程可以分为以下3个步骤</p>
<ol>
<li>命令追加(append): 将redis的写命令追加到AOF的缓冲区aof_buf</li>
<li>文件写入(write)和文件同步(fsync):AOF根据策略将aof_buf中的数据同步到磁盘</li>
<li>文件重写(rewrite):由于AOF文件会越来越大，定期对AOF文件进行重写，从而对写命令进行压缩</li>
</ol>
<h4 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h4><p>redis使用单线程处理客户端命令，如果每次一有写命令就写磁盘的话，磁盘IO就成为redis的性能瓶颈了，所以redis会预先将执行的写命令追加(append)到一个缓冲区(aof_buf)，而不是直接写入文件</p>
<h4 id="文件写入和文件同步"><a href="#文件写入和文件同步" class="headerlink" title="文件写入和文件同步"></a>文件写入和文件同步</h4><ol>
<li>write()<br>为了提高文件写入效率，当用户调用write函数将数据写入文件时，操作系统会先把数据写入到一个内存缓冲区中，当缓冲区被填满或者超过了指定时限时，才真正将缓冲区的数据写入磁盘中</li>
<li>fsync()<br>虽然操作系统对write函数进行了优化，但是也带来了安全问题，如果宕机内存缓冲区中的数据会丢失，因此操作系统同时提供了同步函数fsync(),强制操作系统把缓冲区内部的数据写入到磁盘中，从而保证了数据持久化</li>
</ol>
<p>redis提供了appendfsync配置项来控制AOF缓冲区的文件同步策略，可以配置以下三种策略</p>
<ul>
<li>appendfsync always: 每执行一次命令就保存一次</li>
</ul>
<p>命令写入aof_buf后立即调用系统函数fsync函数同步到aof文件，fsync操作完成后线程返回，整个过程是阻塞的，这种情况下，每次写命令都要同步到AOF文件，硬盘IO成为性能瓶颈,redis只能支持大约几百TPS写入，严重降低了redis的性能</p>
<ul>
<li><p>appendfsync no: 不强制保存，由操作系统决定什么时候写入磁盘<br>命令写入aof_buf中缓冲区调用系统write操作，不对AOF文件做fsync操作，同步由操作系统负责，通常同步周期为30秒，这种情况下、文件同步时间不可控制，且缓冲区内的数据会很多，数据安全性无法得到保证</p>
</li>
<li><p>appendfsync everysec: 每秒钟保存一次<br>命令写入aof_buf缓冲区后，调用系统write操作，write完成后立即返回，fsync同步操作由单独的进程每秒调用一次，everysec是前两种策略的折中方案，是性能和数据安全性的平衡，因此也是redis的默认设置，也是比较推崇的选项</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>文件同步策略</th>
<th>write 阻塞</th>
<th>fsync阻塞</th>
<th>宕机时丢失的数据量</th>
</tr>
</thead>
<tbody><tr>
<td>always</td>
<td>阻塞</td>
<td>阻塞</td>
<td>最多只丢失一个命令的数据量</td>
</tr>
<tr>
<td>no</td>
<td>阻塞</td>
<td>不阻塞</td>
<td>操作系统最后一次对AOF文件fsync后的数据</td>
</tr>
<tr>
<td>everysec</td>
<td>阻塞</td>
<td>不阻塞</td>
<td>一般不超过一秒的数据</td>
</tr>
</tbody></table>
<h4 id="文件重写"><a href="#文件重写" class="headerlink" title="文件重写"></a>文件重写</h4><p>AOF重写过程提供了手动触发和自动触发两种方式</p>
<ul>
<li>手动触发: 直接调用bgrewriteaof,执行方式类似于bgsave，fork子进程执行具体的操作，fork时阻塞</li>
<li>自动触发: 使用auto-aof-rewrite-min-size和auto-aof-rewrite-percentage配置项以及aof_current_size和aof_base_size的状态确定触发时机<ul>
<li>auto-aof-rewrite-min-size: 执行AOF重写时,文件的最小体积，默认64M</li>
<li>auto-aof-rewrite-percentage: 执行AOF重写时，当前AOF文件的大小(aof_current_size)和上一次AOF重写时AOF文件大小(aof_base_size)的比值</li>
</ul>
</li>
</ul>
<h4 id="文件重写流程"><a href="#文件重写流程" class="headerlink" title="文件重写流程"></a>文件重写流程</h4><p>这里以手动调用bgrewriteaof为例，叙述下AOF重写的流程</p>
<ol>
<li><p>客户端通过bgrewriteaof对redis主进程发起AOF重写请求</p>
</li>
<li><p>当前不存在bgsave/bgrewriteaof的子进程时，redis主进程fork子进程(阻塞)，如果发现bgrewriteaof子进程则直接返回，如果发现bgsave子进程则等待bgsave操作完成后再fork操作</p>
</li>
<li><p>主进程fork操作执行完毕后，继续处理其他命令，同时把新的写命令追加到aof_buf中和aof_rewrite_buf缓冲区中</p>
<ul>
<li>文件重写完成之前，主进程会继续把写命令追加到aof_buf缓冲区，根据appendfsync策略将写命令同步到老的AOF文件内，这样可以避免AOF重写失败造成数据丢失，保证原有AOF文件的正确性</li>
<li>由于fork操作时运用写时复制技术，子进程共享fork操作时的内存数据，主进程会把新命令追加到一个aof_rewrite_buf缓冲区中，避免AOF重写失败造成数据丢失这部分数据</li>
</ul>
</li>
<li><p>子进程读取redis进程中的数据快照，生成写入命令后按照命令合并规则批量写入到新的AOF文件</p>
</li>
<li><p>子进程写完新的AOF文件后，向主进程发信号，主进程更新统计信息，具体可以通过info persistence指令查看</p>
</li>
<li><p>主进程接收到子进程的写入完成信号后，将aof_rewrite_buf缓冲区的写命令追加到新的AOF文件</p>
</li>
<li><p>主进程使用新的AOF文件替换旧的AOF文件，AOF重写完成</p>
</li>
</ol>
<h3 id="压缩机制"><a href="#压缩机制" class="headerlink" title="压缩机制"></a>压缩机制</h3><p>文件重写之所以能够压缩AOF文件的大小，主要在于以下原因</p>
<ul>
<li>过期的数据不再写入AOF文件</li>
<li>无效的命令不再写入AOF文件(比如重复的key值设置，set key1 v1 set key1 v2,已经删除的数据)</li>
<li>多条命令可以合并为单个 sadd testset v1 sadd testset v2 sadd testset v3可以合并为 sadd testset v1 v2 v3</li>
</ul>
<h2 id="RDB、AOF对比"><a href="#RDB、AOF对比" class="headerlink" title="RDB、AOF对比"></a>RDB、AOF对比</h2><p>RDB优点</p>
<ul>
<li>与AOF相比，通过rdb文件恢复数据比较快</li>
<li>rdb十分紧凑，适合用来做数据备份</li>
<li>通过RDB进行数据备份，由于使用子进程生成，所以对redis服务器性能影响较小</li>
</ul>
<p>缺点</p>
<ul>
<li>如果服务器宕机的话，使用RDB方式会造成某个时间段内的数据丢失，比如设置10分钟同步一次，或者5分钟写入1000次就同步一次，如果在这个过程中服务器宕机，则这个时间段的数据就会丢失</li>
<li>使用save方式会造成服务器阻塞，同步完成后才能响应后续请求</li>
<li>使用bgsave命令的时候，如果内存中的数据太大，fork也会发生阻塞，另外fork子进程会耗费内存</li>
<li>redis子进程向磁盘写入数据会带来IO压力</li>
</ul>
<p>AOF优点：</p>
<ul>
<li>AOF只是追加日志文件，对服务器性能影响较小，速度比RDB要快，消耗的内存较少<br>AOF的缺点:</li>
<li>AOF生成的日志太大，即使有重写操作，文件体积仍然很大</li>
<li>恢复数据的速度比RDB要慢很多</li>
<li>AOF文件重写也是通过fork子进程的方式处理的，存在fork时阻塞问题</li>
</ul>
<h2 id="RDB还是AOF，如何去选择？"><a href="#RDB还是AOF，如何去选择？" class="headerlink" title="RDB还是AOF，如何去选择？"></a>RDB还是AOF，如何去选择？</h2><p>其实策略的选择主要是看业务中对数据丢失的容忍度，如果可以接受十几分钟或者更多的数据丢失，那么就可以选择RDB,性能更好，如果只能接受秒级别的数据丢失，选择AOF方案更为合适</p>
<h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><p>为什么这里会牵扯到主从复制原理呢？因为主从复制的内容实际上部分内容就是通过RDB来实现的，所以我们在这篇文章一同就给处理了，下面就来讲解下主从复制的原理</p>
<h3 id="如何开启主从复制"><a href="#如何开启主从复制" class="headerlink" title="如何开启主从复制"></a>如何开启主从复制</h3><ul>
<li>redis服务启动后，执行slaveof <masterip> <masterport>命令</masterport></masterip></li>
<li>配置文件配置 slaveof <masterip> <masterport></masterport></masterip></li>
<li>启动命令后面加 –slaveof <masterip> <masterport></masterport></masterip></li>
</ul>
<p>主从复制的开启完全是在从节点发起的，不需要主节点做任何事情</p>
<h3 id="保存主节点信息"><a href="#保存主节点信息" class="headerlink" title="保存主节点信息"></a>保存主节点信息</h3><p>保存主节点信息 从节点服务器内部维护了masterhost和masterport两个字段用于存储主节点ip和端口<br>一般redis节点通过slaveof host port命令来将当前redis服务器变为指定服务器的从属服务器，从而使得从服务器对该主服务器进行复制(实际的复制操作在slaveof命令执行后并返回OK之后才开始进行)</p>
<h3 id="建立socket连接"><a href="#建立socket连接" class="headerlink" title="建立socket连接"></a>建立socket连接</h3><p>从节点每秒1次调用复制定时函数replicationCron(),如果发现有主节点可以连接，便会根据主节点的ip和port，创建socket连接，如果连接成功，则：<br>从节点： 为该socket建立一个专门处理复制工作的文件事件处理器，负责后续复制工作，收接收RDB文件，接收命令传播</p>
<p>主节点:接收到从节点的socket连接后，并将从节点当作是连接到主节点的一个客户端，后续的命令会以从节点向主节点发送命令请求的形式来进行</p>
<h3 id="发送ping命令"><a href="#发送ping命令" class="headerlink" title="发送ping命令"></a>发送ping命令</h3><p>从节点向主节点发送ping命令,主要有以下作用</p>
<ul>
<li>检测主从之间套接字是否可用</li>
<li>检测主节点是否可以接收处理命令</li>
</ul>
<p>可能有以下三种情况</p>
<ul>
<li>主节点返回pong,socket 正常，主节点可以处理请求，复制过程继续</li>
<li>超时，一定时间内仍未收到主节点的回复，说明socket连接不可用，从节点断开socket连接并重连</li>
<li>返回pong以外的结果，如果主节点返回其他结果，如果处理正在超时运行的脚本，说明主节点当前无法处理命令，断开socket连接并重连</li>
</ul>
<h3 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h3><p>如果从节点设置了masterauth选项，则从节点需要进行身份验证，没有配置则跳过<br>身份验证是通过从节点向主节点发送auth命令进行的，auth的参数为配置文件中masterauth的值，如果从节点masterauth和主节点requirepass状态一致，则身份验证通过，复制过程继续，不一致，则断开socket连接，并重连</p>
<h3 id="发送从节点端口信息"><a href="#发送从节点端口信息" class="headerlink" title="发送从节点端口信息"></a>发送从节点端口信息</h3><p>身份验证通过后，从节点会向主节点发送其监听的端口号,主节点将信息保存到该从节点对应的客户端的slave_listen_port中，这个端口信息是用来在主节点查询主从复制状态的时候显示的端口信息，没什么别的作用(info replication)</p>
<h3 id="同步数据"><a href="#同步数据" class="headerlink" title="同步数据"></a>同步数据</h3><p>主从节点的连接建立后，便可以开始数据同步</p>
<ul>
<li>从节点第一次/重新连接主节点，发起数据同步指令(2.8之前是SYNC,2.8之后是PSYNC)</li>
<li>主节点接收到同步指令后，根据主从节点状态的不同，可以分为全量复制和部分复制<h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h4>用于初次复制或者其他无法进行部分复制的情况，将主节点的所有数据发送给从节点，是一个非常重型的操作</li>
</ul>
<p><strong>全量复制过程</strong></p>
<ul>
<li>从节点判断无法进行部分复制，向主节点发送全量复制请求(或从节点发送部分复制请求，主节点判断无法进行部分复制)</li>
<li>主节点接收到全量复制的指令后，执行bgsave,    在后台生成RDB文件，并用一个缓冲区记录记录从生成快照的时间节点后开始执行的写命令</li>
<li>主节点bgsave执行完毕后，将RDB文件发送给从节点，从节点首先清除自己的旧数据，然后载入收到的RDB文件，将状态更新至主节点执行bgsave时候的状态</li>
<li>主节点将缓冲区中的所有写命令发给从节点，从节点执行这些命令，从节点更新至主节点最新状态</li>
</ul>
<p>通过全量复制的过程，可以发现全量复制是非常重型的操作</p>
<ul>
<li>主节点通过bgsave fork子进程进行RDB持久化，该过程非常耗费CPU，内存，硬盘IO</li>
<li>主节点通过网络节点将RDB文件发送给从节点，对主从节点的带宽消耗很大</li>
<li>从节点清空老数据、载入RDB文件的过程是阻塞的，无法响应客户端的命令</li>
</ul>
<h4 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h4><p>用于网络中断后等情况的复制，只将中断期间主节点执行的写命令发送给从节点，比全量复制更加高效，但是如果网络中断时间过长，主节点没有能够完整地保存中断期间的写命令，仍然无法用部分复制还是使用全量复制</p>
<p>由于全量复制在主节点数据量较大的时候效率太低，redis从2.8开始提供部分复制，部分复制的实现依赖于三个重要的概念：</p>
<h5 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h5><p>主节点和从节点分别维护了一份复制偏移量(offset),代表的是主节点向从节点传递的字节数，主节点每次向从节点传播N个字节数据时，主节点offset增加N,从节点每次收到主节点N字节的数据时，从节点的offset增加N<br>offset用于判断主从节点状态是否不一致，二者offset相同，则一致，二者offset不一致，可以根据offset找出从节点缺少的那部分数据，比如主节点offset是1000，从节点offset是500，则需要把主节点501-1000的数据传递给从节点</p>
<h5 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h5><p>主节点维护的、固定长度的、先进先出的队列，默认大小1MB,当主节点开始有从节点时创建，其作用是备份主节点最近发给从节点的数据，无论有几个从节点，复制积压缓冲区都只有一个，命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区，作为写命令的备份，复制积压缓冲区还存储了每个字节对应的复制偏移量，由于复制缓冲区定长且先进先出，所以它保存的是主节点最近执行的写命令，时间较早的会被挤出缓冲区</p>
<p>从节点将offset发送给主节点后，主节点根据offset和缓冲区大小判断能否进行部分复制</p>
<ul>
<li>如果从节点offset偏移量之后的数据，还在主节点复制缓冲区里面，则执行部分复制</li>
<li>如果从节点offset偏移量之后的数据，已不在复制积压缓冲区内，则执行全量复制</li>
</ul>
<h5 id="服务器运行ID-runid"><a href="#服务器运行ID-runid" class="headerlink" title="服务器运行ID(runid)"></a>服务器运行ID(runid)</h5><p>每个redis节点(主从均适用)都有一个runid(启动时随机生成的，每次启动都不一样),主节点初次复制的时候，主节点将自己的runid发送给从节点,从节点保存起来，断线重连后从节点将保存的runid发送给主节点，主节点根据runid判断是否能够进行部分复制</p>
<ul>
<li>如果从节点传过来的runid和和主节点现在的runid相同，证明之前跟主节点同步过，尝试进行部分复制(具体能不能复制还要看offset和复制积压缓冲区情况)</li>
<li>如果传过来的runid和主节点现在的runid不同，说明断线前同步的节点不是当前主节点，只能进行全量复制</li>
</ul>
<h5 id="psync命令的执行"><a href="#psync命令的执行" class="headerlink" title="psync命令的执行"></a>psync命令的执行</h5><p><img src="https://images2018.cnblogs.com/blog/1174710/201806/1174710-20180628011547892-692403928.png" alt><br>图片来源《redis设计与实现》</p>
<h3 id="命令传播阶段"><a href="#命令传播阶段" class="headerlink" title="命令传播阶段"></a>命令传播阶段</h3><p>数据同步完成后，主节点进入命令传播阶段，主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保持主从节点的数据一致性</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://juejin.im/post/5da14c37e51d45784603adb7#heading-17" target="_blank" rel="noopener">一文深度揭秘Redis的磁盘持久化机制</a></p>
<p><a href="https://blog.csdn.net/Stubborn_Cow/article/details/50442950" target="_blank" rel="noopener">Redis 主从复制 原理与用法</a></p>
<p><a href="http://redisdoc.com/replication/slaveof.html" target="_blank" rel="noopener">redis命令参考#slaveof</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/04/17/how-to-guarantee-message-sending-reliably-with-rabbitmq/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/04/17/how-to-guarantee-message-sending-reliably-with-rabbitmq/" itemprop="url">谈谈rabbitmq中如何保证消息的可靠传输</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-17T21:56:46+08:00">
                2020-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/rabbitmq/" itemprop="url" rel="index">
                    <span itemprop="name">rabbitmq</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们经常会在项目里面有用到消息队列的场景，比如贷款场景，用户之前在我们这里借了一笔钱，今天把钱还清了，假设这个时候需要发送一个含有推广链接的短信，或者这个用户还钱的时候正好触发了某个规则，可以对这个用户进行额度提升的操作，都可以用消息队列来处理，那么问题来了，</p>
<ol>
<li>消息是如何投递的？</li>
<li>消息是否成功的投递到了消息队列中？</li>
<li>消息投递过程中是否会有丢失的问题？消息是否被正确消费了呢？<br>带着上述的几个问题并以rabbitmq为例开始我们今天的主题</li>
</ol>
<h1 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h1><p>在计算机网络中，一个可靠的通讯协议可以通知发送者它发送的数据是否成功到达消息接收方，那么在rabbitmq中消息是怎样投递的呢？</p>
<h1 id="rabbitmq-消息投递过程"><a href="#rabbitmq-消息投递过程" class="headerlink" title="rabbitmq 消息投递过程"></a>rabbitmq 消息投递过程</h1><ul>
<li>生产者生产消息</li>
<li>生产者建立与broker的连接</li>
<li>生产者发送消息到broker</li>
<li>broker收到消息，并通过消息中的exchange，routing-key将其路由到指定队列</li>
<li>consumer监听到指定队列的消息并消费</li>
</ul>
<p>那么这里我们可以提出几个问题</p>
<h2 id="生产者是否成功地将消息投递到broker"><a href="#生产者是否成功地将消息投递到broker" class="headerlink" title="生产者是否成功地将消息投递到broker?"></a>生产者是否成功地将消息投递到broker?</h2><p>在默认情况下，rabbitmq 生产者发送完消息后，是不会给rabbitmq返回任何结果的，那很有可能消息发送到一半因为网络或其他原因，消息没有到达broker，消息直接丢失，这种情况是我们无法忍受的，当然rabbitmq也提供了两种方式解决这种问题，供我们自行选择。</p>
<ul>
<li>事务消息模式</li>
<li>发送方确认模式</li>
</ul>
<h2 id="生产者的消息到达broker后，在broker中是否会丢失？"><a href="#生产者的消息到达broker后，在broker中是否会丢失？" class="headerlink" title="生产者的消息到达broker后，在broker中是否会丢失？"></a>生产者的消息到达broker后，在broker中是否会丢失？</h2><p>消息到达broker后，很有可能因为一些原因导致broker重启或者退出，因为rabbitmq的消息默认都是在内存里面的，发生重启会导致消息丢失，这也是我们无法忍受的，这里用到了rabbitmq中的持久化机制，需要我们同时保证3个条件，才能保证消息的持久化</p>
<ul>
<li>消息投递时开启了持久化</li>
<li>目标交换机开启了持久化</li>
<li>目标队列开启了持久化</li>
</ul>
<ul>
<li>消息是否被消费者成功消费呢？</li>
</ul>
<p>正常来讲如果消息投递成功了，并且在broker开启了持久化是不是就能保证消息可靠传输了呢？答案是否定的，消费者消费也可能出现问题，比如消费失败，或者消息压根就没有到达消费者(丢了)，这个时候又该如何处理呢？RabbitMQ这里提供了一个消费确认的机制，这种机制分为手动确认和自动确认</p>
<ul>
<li>manual ack 需要业务方根据消费情况手动确认消息消费情况</li>
<li>auto ack 消息一经broker发出，就认为已经投递成功了</li>
</ul>
<p>很显然 autoack这种是有消息丢失风险的，我们很难保证业务方正确消费的情况，所以一般来说我们想要保证消费的可靠性需要开启手动ack模式，确保业务方正确消费后，再进行确认，下面就说一下手动确认在标准AMQP协议中定义的手动ack的接口方法</p>
<ul>
<li><p>basic.ack 如果业务方正确消费了消息，那么业务方需要给broker发送一个ack消息，代表消息已经正确处理, broker可以将这条消息删除了</p>
</li>
<li><p>basic.reject 如果业务方发生了异常或者因为某些原因导致无法消费消息，可以给broker发送拒绝消息，让这条消息重新入队，以便让别的消费者可以消费这条消息   对应标准AMQP0.9.1.1协议中的 basic.reject方法</p>
</li>
<li><p>basic.nack  在basic.reject的基础上提供批量拒绝消息的方法</p>
</li>
</ul>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://www.rabbitmq.com/confirms.html" target="_blank" rel="noopener">rabbitmq官网#Consumer Acknowledgements and Publisher Confirms</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/04/16/how-to-guarantee-redis-high-availability/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/04/16/how-to-guarantee-redis-high-availability/" itemprop="url">谈谈如何保障redis的高可用?</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-16T20:02:54+08:00">
                2020-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>
我们都知道，系统中每引入一个新的中间件，都会造成可用性的降低，举个例子，本来我只需要保障应用本身高可用即可，现在又引入了中间件A，如果它宕机了怎么办？所以，伴随着这个话题，我们今天就来聊聊如果保证redis的高可用

</p>

<h1 id="高可用方案"><a href="#高可用方案" class="headerlink" title="高可用方案"></a>高可用方案</h1><p>为什么要用保证redis的高可用？redis单点会带来哪些问题呢？</p>
<ul>
<li>单点故障问题<br>如果目前只有一台redis服务器在运行，发生机器故障，服务直接不可用，如果故障比较严重，磁盘损坏了，数据就损坏了，单台机器时没有办法保证数据的安全性的</li>
<li>容量瓶颈<br>redis是内存存储的，单机很容易受到内存容量的限制</li>
</ul>
<h2 id="主从复制模式"><a href="#主从复制模式" class="headerlink" title="主从复制模式"></a>主从复制模式</h2><p>主从复制，顾名思义，分为主节点和从节点，主节点负责写，从节点负责扩展主节点的读能力，并且可以将主节点的数据同步给从节点，一旦发现主节点发生故障，从节点可以随时顶上来</p>
<p><strong>主从复制模式面临的问题</strong></p>
<ul>
<li>并没有解决单点的写压力</li>
<li>主节点发生故障的时候，需要手动将从节点晋升为主节点，同时需要通知应用放更改主节点地址并重启，并且需要命令其他从节点复制新的主节点，整个过程需要人工干预</li>
<li>主节点的存储能力受到单机的限制</li>
</ul>
<p>redis 主从复制和sentinel架构示意图如下<br><img src="https://s1.ax1x.com/2020/04/07/GgEFqx.png" alt></p>
<h2 id="redis-sentinel-哨兵模式"><a href="#redis-sentinel-哨兵模式" class="headerlink" title="redis sentinel 哨兵模式"></a>redis sentinel 哨兵模式</h2><p>哨兵模式实际上就是在主从复制的基础上，加上了一层监控的哨兵节点。Redis-sentinel也是官方提供的高可用方案，哨兵模式是在2.6以后开始提供的，如果需要在生产上使用，尽量使用2.8之后的版本，比较稳定。哨兵模式下在主节点发生故障时，可以实现自动的主备切换，并且可以监控多个主从集群，哨兵节点本身也支持集群，毕竟哨兵只有单个节点也无法支持哨兵节点的高可用，并且如果唯一的哨兵如果宕机了，哨兵模式又变回主从复制模式了，又将无法自动的进行主备切换了。<br>客户端连接的是哨兵节点，只要连接任意一个哨兵节点，就可以获得redis主从集群中的信息。</p>
<p><img src="https://s1.ax1x.com/2020/04/16/JEEvHs.png" alt><br>图片引用自<a href="https://juejin.im/post/5d76f54b6fb9a06aeb10e53c#heading-8" target="_blank" rel="noopener">Redis哨兵（Sentinel）模式快速入门</a></p>
<h3 id="哨兵节点的作用"><a href="#哨兵节点的作用" class="headerlink" title="哨兵节点的作用"></a>哨兵节点的作用</h3><h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a><strong>监控</strong></h4><p>sentinel 会不间断的检查主服务器和从服务器是否正常运行</p>
<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a><strong>通知</strong></h4><p>当被监控的某个redis服务器如果出现问题，sentinel通过api脚本向管理员或者其他应用程序发送通知</p>
<h4 id="自动故障迁移"><a href="#自动故障迁移" class="headerlink" title="自动故障迁移"></a><strong>自动故障迁移</strong></h4><p>当主节点不能正常工作时，sentinel会开始一次自动的故障迁移，它将会与失效主节点是主从关系的其中一个主节点的其中一个从节点升级为新的主节点，并且将其他的从节点指向新的主节点。</p>
<h4 id="配置提供者"><a href="#配置提供者" class="headerlink" title="配置提供者"></a><strong>配置提供者</strong></h4><p>在redis sentinel模式下，客户端在初始化连接的是sentinel的集合，从中获取主节点的信息。</p>
<h3 id="主观下线-SDOWN"><a href="#主观下线-SDOWN" class="headerlink" title="主观下线(SDOWN)"></a>主观下线(SDOWN)</h3><p>主观下线其实是指单个sentinel实例对节点做出的下线判断，默认情况下，每个sentinel会以每秒一次的频率对redis节点和其他sentinel节点发送PING命令，并通过节点的回复来判断是否在线。</p>
<p>主观下线适用于所有主节点和从节点。如果在down-after-milliseconds毫秒内，sentinel没有收到目标节点的有效回复(+PONG,-LOADING,-MASTERDOWN)，则会判定为该节点为主观下线</p>
<h3 id="客观下线-ODOWN"><a href="#客观下线-ODOWN" class="headerlink" title="客观下线(ODOWN)"></a>客观下线(ODOWN)</h3><p>客观下线是指多个sentinel实例对同一个实例进行主观下线判断。</p>
<p>客观下线只适用于主节点，如果哨兵节点发现主节点主观下线后，会通过is-master-down-by-addr命令向其他sentinel节点询问该节点的状态，若果超过<quorum>个数的节点认为主节点不可达(主节点已经主观下线)，则sentinel节点会判定主节点为客观下线，只有发现主节点客观下线后，才会开启自动的故障迁移</quorum></p>
<h3 id="自动故障迁移-automatic-failover-过程"><a href="#自动故障迁移-automatic-failover-过程" class="headerlink" title="自动故障迁移(automatic-failover)过程"></a>自动故障迁移(automatic-failover)过程</h3><ol>
<li>sentinel发现主节点主观下线，修改其状态为SDOWN</li>
<li>sentinel和其他sentinel节点确认master是否down掉(SENTINEL is-master-down-by-addr)，确认其状态为客观下线(ODOWN),</li>
<li>sentinel间进行leader选举，由被选出的leader sentinel节点来进行后续的故障切换工作，选举基于Raft协议</li>
<li>sentinel节点开始进行故障切换，并选出合适的从节点作为主节点</li>
<li>对选出的从节点执行 slaveof no one将其晋升为新的主节点</li>
<li>对其余的从节点发送命令，使其变为新的主节点的从节点，并且从新的主节点复制数据</li>
<li>leader sentinel继续监控已下线主节点，一旦其重新上线，就把他降级为新的主节点的从节点，并且从新的主节点中复制数据</li>
</ol>
<h3 id="leader哨兵节点选举"><a href="#leader哨兵节点选举" class="headerlink" title="leader哨兵节点选举"></a>leader哨兵节点选举</h3><ol>
<li><p>某个sentinel发现master节点主观下线后，执行以下操作</p>
<ul>
<li>如果该哨兵节点没有投过票，它就成为candidate</li>
<li>如果该哨兵节点已经投过票，则在2倍的故障时间内就不会成为leader，也就是相当于一个follower</li>
</ul>
</li>
<li><p>sentinel节点成为candidate后执行以下操作</p>
<ul>
<li>更新故障转移状态为start</li>
<li>令当前epoch + 1,即发起新一轮的选举,在sentinel中epoch相当于Raft协议中的term</li>
<li>向其他节点发送SENTINEL is-master-down-by-addr指令，该命令包含自己的epoch</li>
<li>投自己一票，投票的方式是将自己master结构中的leader和leader_epoch改成投给的sentinel和它的epoch</li>
</ul>
</li>
<li><p>其他节点收到Candidate的SENTINEL is-master-down-by-addr命令，如果收到命令的sentinel判断发现当前epoch和通过命令收到的epoch一样，证明它已经投过票了，当前epoch内该sentinel就只能成为follower</p>
</li>
<li><p>candidate会不断统计自己的票数，直到他发现认同他成为leader超过一半且超过它配置的quorum，则该candidate成为leader哨兵节点</p>
</li>
<li><p>在一个选举时间内，如果一个candidate没有获得超过一半的票数且超过quorum,则该次选举失败</p>
</li>
<li><p>如果在一个epoch内，没有一个candidate获得更多的票数，则2倍故障转移的时间后，candidate增加epoch并重新投票</p>
</li>
</ol>
<h3 id="master节点选举"><a href="#master节点选举" class="headerlink" title="master节点选举"></a>master节点选举</h3><p>从已经宕机的主节点的从节点中挑选一个节点作为主节点，这个主节点是按照以下规则选出来的</p>
<ul>
<li>slave优先级(手动配置的) 如果有配置最高的slave节点，则返回，没有则继续</li>
<li>复制偏移量最大的(对主节点数据复制的最完整的从节点)，如果有则返回，没有则继续</li>
<li>启动最早的slave节点(run_id最小)</li>
</ul>
<h2 id="redis-cluster"><a href="#redis-cluster" class="headerlink" title="redis cluster"></a>redis cluster</h2><p>来聊redis cluster之前先来聊聊几个问题 </p>
<h3 id="水平扩展性"><a href="#水平扩展性" class="headerlink" title="水平扩展性"></a>水平扩展性</h3><p>水平扩展性或者说给系统中添加节点的能力，对于redis来说特别重要，redis只能进行垂直扩展(给予redis进程更多的CPU或者内存)，不过垂直扩展的特点也很明显，很快就会变得非常昂贵并且变得无法管理。</p>
<p>我们只能通过把redis中的数据进行分区，将不同分区的数据存储到不同的redis实例中，很多公司针对redis已经实现了自己的分区方案，不过大部分方案都是在客户端进行分区，也就是，数据在哪个节点进行读写是客户端来决定的，这个方法的缺点也很明显，所有的客户端都要实现这个相同的分区策略，并且连接到同一个redis实例的不同的redis客户端将会紧紧的耦合在一起。</p>
<p>另一种分区策略对客户端进行了解耦，就是用代理进行协助分区，Twitter就采用了这种分区策略，在这种方式下，<br>proxy就像一个在客户端和redis实例之间的一个单独的节点负责处理数据分区，虽然这种方式给客户端解耦，但是又引入了proxy单点故障的问题，又需要考虑proxy的高可用问题，还有一个问题就是如果将来需要添加或者删除节点的时候，又会带来数据的重新分区，如果只是用redis做缓存的话，这个问题没什么大不了的，但是如果用来做数据存储，只是改变分区策略可能会引起数据的“丢失”(原来的key值可能会被分区到别的redis实例上面去了)，并且这个新的redis实例上还没有数据，调整了分区策略后必须要进行数据迁移</p>
<h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>当在一个大型企业级应用中依赖一个数据库的时候，是不允许数据库有停机时间的，现代的数据库必须要尽可能地有容灾和容错能力，并且不需要人为干预。尽管redis实例很少发生宕机，但是也有一些异常情况会导致redis实例不可用，由于没有好的redis高可用方案，一些公司开始自行研发自己的redis高可用方案，但是大部分用户都没有高可用方案，并且一些stackoverflow上面的问答都太专业化了，普通用户根本就被抛弃了，于是redis团队立刻研发了一套高可用方案redis sentinel,这是一个官方的高可用方案，但是引入了额外的复杂度，并且这种方案并不提供主节点的水平扩展，在redis实例外还需要3台额外的机器(存放哨兵节点)。</p>
<p>为了解决上述问题，redis 3.0.0发布了redis cluster ，redis cluster是一个多主多从并且去中心的架构，redis cluster简而言之就是一个数据分片策略，它可以在集群运行的时候将数据重新分片到其他节点上面，并且提供了故障切换的方法可以确保系统可以应对各种各样的故障。redis cluster使用hash分区将key分配到16,384个hash槽内，集群的每一个主节点负责一部分hash槽，集群中的每一个从节点负责复制指定主节点的数据，并且可以重新分配给别的主节点或者是被选举为新的主节点，主节点接收来自客户端的读和写请求，从节点不与客户端做任何交互，只做主节点的数据备份。</p>
<p><img src="https://img-blog.csdn.net/20180902175117548?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xvdmU5MDU2NjE0MzM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br>图片引用自<a href="https://blog.csdn.net/love905661433/article/details/82317635" target="_blank" rel="noopener">Redis Cluster集群使用与原理</a></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://juejin.im/post/5d76f54b6fb9a06aeb10e53c#heading-8" target="_blank" rel="noopener">Redis哨兵（Sentinel）模式快速入门</a><br><a href="https://juejin.im/post/5e47cbe451882549522ab508#heading-17" target="_blank" rel="noopener">Redis 知识汇总</a><br><a href="https://www.credera.com/blog/technology-insights/open-source-technology-insights/an-introduction-to-redis-cluster/" target="_blank" rel="noopener">An Introduction to Redis Cluster</a></p>
<p>关于Raft协议，<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="noopener">这个网站</a>上面有动画演示，非常容易理解，可以去了解下</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/04/16/about-redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/04/16/about-redis/" itemprop="url">聊聊中间件之redis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-16T11:28:01+08:00">
                2020-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>
不知不觉4月份已经过去大半了，转眼间自己已经失业半个月了，感觉还有好多东西没有复习，不管怎么样，不能让自己闲下来,今天就来整理一下redis相关的内容
</p>

<h1 id="about-redis"><a href="#about-redis" class="headerlink" title="about redis"></a>about redis</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redis是一个使用ANSI C编写的开源、支持网络、基于内存、可选持久性的键值对存储数据库。  --- wikipedia</span><br></pre></td></tr></table></figure>

<p>redis是一款基于内存的数据库，即NOSQL,采用单线程模型，能支持10W的并发<br>常用的数据结构 String List Set ZSet Hash<br>持久化方式:RDB(快照)，AOF（日志追加）</p>
<h1 id="redis为什么高性能？"><a href="#redis为什么高性能？" class="headerlink" title="redis为什么高性能？"></a>redis为什么高性能？</h1><ul>
<li>单线程模型避免线程上下文切换问题</li>
<li>纯内存操作</li>
<li>核心基于非阻塞的IO多路复用</li>
</ul>
<h1 id="redis中的数据结构"><a href="#redis中的数据结构" class="headerlink" title="redis中的数据结构"></a>redis中的数据结构</h1><h2 id="string字符串-Simple-Dynamic-String-动态字符串"><a href="#string字符串-Simple-Dynamic-String-动态字符串" class="headerlink" title="string字符串 Simple Dynamic String(动态字符串)"></a>string字符串 Simple Dynamic String(动态字符串)</h2><p>String是redis里面最简单的key-value类型了，它的value不仅可以是String还可以是数字，它也是Memcached中的唯一的数据类型，redis String底层使用SDS(Simple Dynamic String)实现,常见的用法就是缓存、计数等功能，常用指令 set get decr(-1) incr(+1) mget(获取一个或多个给定key的值)</p>
<h2 id="list-列表"><a href="#list-列表" class="headerlink" title="list 列表"></a>list 列表</h2><p>list就是列表，在redis底层是用链表实现的，通过列表可以轻松实现最新消息列表等与插入序有关的业务。<br>常用指令 lpush(链表头插入一个元素),lpop(链表头删除一个元素),rpush,rpop,lrange(获取指定范围内的元素)</p>
<h2 id="set-集合"><a href="#set-集合" class="headerlink" title="set 集合"></a>set 集合</h2><p>set就是一个集合，一堆不重复值得集合，利用redis提供的set可以存储一些集合性的数据，比如微博中一个人关注的人，粉丝等等，redis还对set提供了一系列的函数可以实现对集合的并、交、差，这就可以非常方便的实现共同好友、共同关注、二度好友等功能</p>
<p>常用指令 sadd(向一个集合中添加一个或多个元素) spop(移除一个随机元素) srem(移除一个或多个指定元素) smembers(获取集合所有成员) sunion(求并集)</p>
<h2 id="zset有序集合-内部实现为skip-list跳跃表"><a href="#zset有序集合-内部实现为skip-list跳跃表" class="headerlink" title="zset有序集合 内部实现为skip list跳跃表"></a>zset有序集合 内部实现为skip list跳跃表</h2><p>zset(又称sorted set),有序集合，比set增加了一个score(权重)的概念，使得集合中的元素可以按照score进行排序，这一特性特别适合做排行榜</p>
<h2 id="hash-字典"><a href="#hash-字典" class="headerlink" title="hash 字典"></a>hash 字典</h2><p>hash几乎可以等价于java中的hashmap,底层采用数组+链表的结构，常用于存储对象<br>常用指令 hget,hset,hgetall</p>
<h1 id="redis常见的使用场景"><a href="#redis常见的使用场景" class="headerlink" title="redis常见的使用场景"></a>redis常见的使用场景</h1><ul>
<li>缓存</li>
<li>单线程模型可做分布式锁</li>
<li>排行榜 有序集合可以实现</li>
<li>计数器 商品浏览量 视频播放数 redis 提供的incr 内存操作 性能非常好</li>
<li>分布式会话</li>
<li>社交网络 共同关注/共同好友 redis提供的hash和集合(交并差)</li>
</ul>
<h1 id="redis-分布式锁"><a href="#redis-分布式锁" class="headerlink" title="redis 分布式锁"></a>redis 分布式锁</h1><h2 id="单节点分布式锁"><a href="#单节点分布式锁" class="headerlink" title="单节点分布式锁"></a>单节点分布式锁</h2><p>单节点的分布式锁(只有一个master节点)往往是不可靠的，虽然实现起来很简单，但是如果主节点宕机或者没有来得及同步数据，给从节点导致从节点选举为master时候锁丢失，这种方案很明显是不可靠的</p>
<h3 id="setnx-del"><a href="#setnx-del" class="headerlink" title="setnx + del"></a>setnx + del</h3><p>执行业务前通过 setnx 获取锁，执行完业务删除锁，表面上看起来没什么问题，但是如果业务的执行出现了异常，再或者服务宕机没有来得及删除该锁，导致这个业务再次执行的时候再也获取不到这个锁,从而导致死锁，这样是行不通的</p>
<h3 id="setnx-expire"><a href="#setnx-expire" class="headerlink" title="setnx + expire"></a>setnx + expire</h3><p>业务先通过set nx获取锁，然后再通过expire命令为锁设置过期时间，这种情况实际上跟先加锁后删除的效果是一样的，如果业务执行出现了异常，expire没有被执行，业务还是无法获取这个锁，出现这样的问题的根本原因实际上就是因为 setnx + del || expire是两条指令，并非一个原子性操作，两个指令如果能同时执行就可以避免这样的问题 </p>
<h3 id="lua脚本-setnx-expire"><a href="#lua脚本-setnx-expire" class="headerlink" title="lua脚本 setnx + expire"></a>lua脚本 setnx + expire</h3><p>setnx + expire 本身不是原子性的，但是redis提供了单线程模型执行lua脚本，保证脚本在运行过程中不会被任意其他请求打断，通过lua脚本执行相同的命令即可保证这两条命令的原子性</p>
<h3 id="set-nx-ex"><a href="#set-nx-ex" class="headerlink" title="set nx  ex"></a>set nx  ex</h3><p>redis 2.6.12开始，set命令开始支持EX、NX、PX、XX等选项，可以完全替代setnx等操作，而且还是原子性的，可以执行通过set实现单节点的分布式锁。</p>
<h2 id="多节点redis分布式锁"><a href="#多节点redis分布式锁" class="headerlink" title="多节点redis分布式锁"></a>多节点redis分布式锁</h2><h3 id="RedLock-真正意义上的分布式锁"><a href="#RedLock-真正意义上的分布式锁" class="headerlink" title="RedLock(真正意义上的分布式锁)"></a>RedLock(真正意义上的分布式锁)</h3><p>假设当前有5个独立的redis master节点</p>
<ul>
<li>获取当前unix时间戳 以毫秒为单位</li>
<li>依次从5个实例尝试，使用相同的key和value获取锁，客户端在请求锁的时候，应该设置一个超时时间，防止在请求锁的时候避免由于服务端已经挂掉的时候，客户端还在死等响应结果。如果服务端没有在规定的超时时间内响应，客户端应该尽快从另外一个redis实例中获取锁</li>
<li>客户端使用当前时间减去开始获取锁的时间，就得到锁的使用时间，并且当且仅当从大多数redis节点都获取到锁的时候，并且锁使用的时间小于锁失败时间时，锁才获取成功</li>
<li>如果获取到了锁，锁的真正有效时间等于有效时间减去第三步获取锁所使用的时间</li>
<li>如果获取锁失败，客户端应该在所有的redis实例上进行解锁，防止某些节点获取到锁，但是客户端没有得到响应，从而导致接下来的一端时间里客户端不能重新获取锁</li>
</ul>
<p>但是这种分布式锁真的可靠吗？ 业务时间超过了分布式锁的可用时间，这个锁还有意义吗？</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/blog/images/avatar.jpg" alt="mr_cris">
            
              <p class="site-author-name" itemprop="name">mr_cris</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/blog/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/blog/tags/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mr_cris</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>  总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  














  





  

  

  

  
  

  

  

  

</body>
</html>
