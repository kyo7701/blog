<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="cris&#39;s blog">
<meta property="og:url" content="https://kyo7701.github.io/blog/index.html">
<meta property="og:site_name" content="cris&#39;s blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="cris&#39;s blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://kyo7701.github.io/blog/">





  <title>cris's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">cris's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blog/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2021/06/14/about-mysql-implicitly-type-convertion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2021/06/14/about-mysql-implicitly-type-convertion/" itemprop="url">浅淡MySQL中的隐式类型转换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-14T00:22:10+08:00">
                2021-06-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h2><p>最近在工作当中，无意发现varchar类型的字段，如果与数字进行等值比较，得出来的结果跟预期不一致。当时很是好奇，于是工作之余将此问题原因查明，并作为记录</p>
<h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>这里就不再取公司的业务数据作为例子，而是直接找到了<a href="https://dev.mysql.com/doc/refman/5.7/en/type-conversion.html" target="_blank" rel="noopener">mysql官网中的例子</a>如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT &apos;9223372036854775807&apos; = 9223372036854775807;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>-&gt; 1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT &apos;9223372036854775807&apos; = 9223372036854775806;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>-&gt; 1</p>
</blockquote>
<p>我们可以清晰的看到两个等式左侧的字符串的值是相等的,但右侧的数字却不相等，但是两个等式比较结果确是相同的，如果我们用这种方式(varchar列与数值进行比较运算)来做等值比较，那么产生的结果很可能不是我们预期的内容</p>
<h2 id="官网解释"><a href="#官网解释" class="headerlink" title="官网解释"></a>官网解释</h2><blockquote>
<p>Comparisons between floating-point numbers and large values of INTEGER type are approximate because the integer is converted to double-precision floating point before comparison, which is not capable of representing all 64-bit integers exactly. For example, the integer value 2^53 + 1 is not representable as a float, and is rounded to 2^53 or 2^53 + 2 before a float comparison, depending on the platform.</p>
</blockquote>
<p>我理解这里的大致意思是说，在浮点数和大的Integer类型的数值发生比较的时候，得到的结果是一个近似的结果。<br>在integer数值与浮点数进行比较之前会被转化为双精度浮点数,这就导致转换后的结果不能精确的表示所有64位整数，举例来说，整型的2^53 + 1是不能被浮点数表示的，发生浮点整数比较时会被近似为2^53或2^53 +2,具体结果视平台不同而不同</p>
<p>看到这里可能会比较疑惑，我明明用的是一个字符串列与数值进行比较，怎么就跟浮点数和整数扯上关系了？我们继续读官方文档</p>
<p>这里在官方文档前面其实描述了,我在这里就直接给出我的理解了，官网的具体链接放于文章末尾，感兴趣的同学可以自行去阅读</p>
<p>当发生比较运算时，以下规则描述了类型转换是如何发生的:</p>
<ul>
<li>如果运算符两侧的操作数有一个或一个以上为NULL，比较结果则为NULL(如果是NULL-safe运算符&lt;=&gt;则不会出现上述结果,select NULL &lt;=&gt; NULL;结果为1,并且不会发生类型转换);</li>
<li>如果运算符两侧的操作数都是字符串，它们会被当作字符串比较;</li>
<li>运算符两侧都是integer,它们会被当作integer来比较;</li>
<li>16进制的value如果不与数字发生比较会被当作二进制串处理;</li>
<li>如果其中一个操作数是timestamp或者datetime并且另外一个操作数是常量，常量会被先行转换为时间戳在进行比较，这么做是为了对ODBC更为友好 但这种操作并不支持in()查询,为了安全起见，在这种比较的时候，请尽量使用完整的datetime、date或者是time的字符串来进行比较。举例来说:在date或者是time数据间进行比较的时候,如果想达到最好的比较效果，请尽量使用显示的类型转换(cast )来将两个操作数转换成想要比较的数据类型;</li>
<li>一个单行的子查询将不被被当做constant来处理，举例来讲,一个datetime类型的数值和一个返回一个integer类型的子查询,会被当作两个integer数来进行比较，这个integer数将不会被转化为临时变量，如果想要当作datetime类型进行比较 请使用cast进行显示的类型转换;</li>
<li>如果操作数中有decimal，这种比较运算将根据另一个操作数的类型来决定。另一个操作数如果是decimal或者integer,则比较会被当作decimal类型进行比较,另一个操作数如果是float类型，则会被当作float类型进行比较;</li>
<li>所有其他情况，均会被当做浮点数进行比较，举个例子来讲,一个字符串和一个数字进行比较会被当作浮点数来进行比较</li>
</ul>
<p>那么通过上述规则,我们不难看出，在用varchar列与数字进行比较的时候则会被当作浮点数进行比较，那么这种情况发生的时候，它们每次并不一定是同一结果，integer操作数会被CPU转换为浮点型，而string的转换会以浮点数的按位乘法的方式进行转换，此外，操作结果还会受到计算机架构、编译器版本、编译器优化等因素的影响。<br>要想避免这种情况，其中的一种办法就是避免这种浮点数的隐式转换发生，比如我们最开头的例子:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CAST</span>(<span class="string">'9223372036854775807'</span> <span class="keyword">AS</span> <span class="keyword">UNSIGNED</span>) = <span class="number">9223372036854775806</span>;</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>其实我之前之所以没遇到这种问题,完全是因为我自己在写查询语句的时候，使的SQL语句的语义尽量地准确，比如varchar类型的列，我就只使用字符串与之进行比较运算，这就完全规避掉了这种隐式转换的发生,这里其实并不是说楼主水平有多么好或者吹嘘自己，而是想说保持一个良好的编码习惯会为自己避免很多问题的发生，节省很多时间，但是辩证地来看，若经常保持不良好的编码习惯，也能经常收获一些意想不到的问题，这个时候如果肯下点功夫，虽然花费了大量精力去处理问题，但却能收获到一些良好编程习惯接触不到的知识。但无论是采用哪种编码习惯,遇到问题的时候一定要下功夫去查明真相，如果当时没有精力去查明这种问题，工作之余一定要将问题查明原因，否则任你工作经验再多，积累的无非只是”工作年份”而并非”工作经验”</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://dev.mysql.com/doc/refman/5.7/en/type-conversion.html" target="_blank" rel="noopener">MySQL5.7官方文档/type-conversion</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2021/03/19/about-thread-pool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2021/03/19/about-thread-pool/" itemprop="url">聊聊线程池</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-19T14:49:26+08:00">
                2021-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在开始做这期博客之前，作者提出了几个问题，文章将通过这几个问题穿插着了解线程池</p>
<ol>
<li><p>线程池是什么？</p>
</li>
<li><p>为什么要用线程池？他解决了哪些问题？</p>
</li>
<li><p>有哪些默认的线程池？他们有没有什么问题?</p>
</li>
<li><p>线程池工作流程？</p>
</li>
<li><p>work工作流程?</p>
</li>
<li><p>线程池的参数有哪些？生产环境该如何根据业务调整这些参数？</p>
</li>
</ol>
<hr>
<p>进入正题</p>
<h1 id="1-什么是线程池"><a href="#1-什么是线程池" class="headerlink" title="1. 什么是线程池"></a>1. <strong>什么是线程池</strong></h1><p><strong><a href="https://en.wikipedia.org/wiki/Thread_pool" target="_blank" rel="noopener">wikipedia</a></strong></p>
<blockquote>
<p>计算机科学中,线程池是一种为了取得应用程序并发度的软件设计模式。它也被成为replicated workers or<br>work-crew model,一个线程池在其内部维护这一组为了等待执行并发任务的线程，通过对这一组线程的维护，<br>这种模式提高了性能并且避免了短任务频繁创建及销毁的执行延迟。</p>
</blockquote>
<p><strong><a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener">美团技术团队</a></strong></p>
<blockquote>
<p>线程池是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，比如MySQL。   </p>
</blockquote>
<p><strong>池化思想</strong><br>顾名思义，将资源统一在一起管理解决资源分配的问题，最大化收益并最小化风险。</p>
<p>池化思想不仅可以用在计算机领域，也可以用于人力管理、工作管理设备、金融管理(例如将RD认为是一种资源，将所有RD统一放入池子里统一管理，分配开发任务等等)，其他几种使用场景包括以下:</p>
<ul>
<li>内存池(Memory Pooling) : 预先申请内存，提高内存申请速度，减少内存碎片</li>
<li>连接池(Connection Pooling) : 预先申请连接信息，提升申请连接的速度，降低系统的开销</li>
<li>实例池(Object Pooling) : 循环使用对象，减少资源在初始化和释放时的昂贵损耗。</li>
</ul>
<h1 id="2-为什么要用线程池？-线程池有什么好处？"><a href="#2-为什么要用线程池？-线程池有什么好处？" class="headerlink" title="2. 为什么要用线程池？ 线程池有什么好处？"></a>2. 为什么要用线程池？ 线程池有什么好处？</h1><ul>
<li>降低资源损耗 通过池化技术重复利用已经创建的线程，    降低线程创建和销毁带来的损耗。</li>
<li>提高响应速度 任务到达时，无需等待线程创建即可立即执行</li>
<li>提高对线程的管理性，线程是稀缺资源，无限制的创建不仅会消耗系统的资源，并且还会因为资源分配不合理导致调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控</li>
<li>提供更多可以调控的功能，线程池具备可拓展性，允许开发人员向其中添加更多的功能。比如延迟队列，允许任务延期执行</li>
</ul>
<h1 id="3-有哪些默认的线程池"><a href="#3-有哪些默认的线程池" class="headerlink" title="3.有哪些默认的线程池"></a>3.有哪些默认的线程池</h1><p>在Java当中，主要通过类Executors提供的几个工厂方法来创建默认的线程池，其中JDK1.8中主要提供以下6种默认的实现</p>
<ul>
<li>newSingleThreadExecutor</li>
<li>newFixedThreadPool</li>
<li>newWorkStealingPool</li>
<li>newSingleThreadScheduledExecutor</li>
<li>newScheduledThreadPool</li>
<li>newCachedThreadPool</li>
</ul>
<p>这些工厂方法都是通过ThreadPoolExecutor实现的，只是不同的方法构造参数不尽相同</p>
<h1 id="文章未完成待续…"><a href="#文章未完成待续…" class="headerlink" title="文章未完成待续…."></a>文章未完成待续….</h1><p>to be continued</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/07/26/about-mybatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/07/26/about-mybatis/" itemprop="url">聊聊ORM框架之mybatis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-26T00:19:58+08:00">
                2020-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>周五本来想着跑个步就打算睡觉来着，没想到还能跟前同事大佬在一起交流一波技术(其实是单方面的吊锤我，哈哈)，大佬带我系统的分析了几个常见框架的源码，今天正好趁热，赶紧把已经了解的内容记录下来，便于以后进行查阅</p>
<h1 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h1><p>在正式了解mybatis之前，其实需要先了解一些概念，比如什么是ORM(Object Relational Mapping,简称ORM)</p>
<p> wikipedia</p>
<blockquote>
<p>对象关系映射（英语：Object Relational Mapping，简称ORM，或O/RM，或O/R mapping），是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的“虚拟对象数据库”。 </p>
</blockquote>
<p>阮一峰的网络日志《ORM实例教程》</p>
<blockquote>
<p>在面向对象编程语言当中，所有的实体都可以被视作对象，而关系数据库当中，则是通过实体与实体间的关系来连接数据，很早就有人提出，关系也可以用对象来表达，这样的话，就可以通过面向对象的思想来操作关系型数据库。    </p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/07/26/apPO54.png" alt></p>
<p>也就是说，ORM是通过实例对象的语法，来完成关系型数据库操作的技术。</p>
<ul>
<li>数据库中的表      —》 类</li>
<li>数据库中的一行记录 —》 对象</li>
<li>字段             —》 对象的属性</li>
</ul>
<p>在Java编程语言中，常用的ORM框架无非两种，一种是Hibernate，一种是Mybatis,前一种是拥抱面向对象的，它能够维护Object—&gt; Relation和 Relation —&gt; Object的映射，是完整的ORM框架，而Mybatis则不是这样，mybatis只实现了Relation—&gt; Object这一部分内容，它是拥抱SQL的，所以说Hibernate是完整的ORM框架，而Mybatis是不完整的ORM框架，Hibernate这种接近面向对象的操作方式也使得它拥有一系列的优点(HQL语言)，但是由于经常使用HQL语言容易使得对底层SQL的细节忽略，从而导致一些SQL在出现性能问题后优化会非常困难，由于本节只讲mybatis，所以hibernate和mybatis的对比区别这里就不再过多赘述了。</p>
<h1 id="mybatis框架的工作流程"><a href="#mybatis框架的工作流程" class="headerlink" title="mybatis框架的工作流程"></a>mybatis框架的工作流程</h1><p>由于现阶段用springboot比较多，我们现在就拿集成已经非常方便的mybatis-spring-boot-starter来进行本文的讲解，代码版本</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
    &lt;version&gt;2.1.3&lt;/version&gt;
&lt;/dependency&gt;</code></pre><p>其实一聊到springboot，想到的第一件事就应该是自动装配，那就需要看一下mybatis是不是有mybatisAutoConfigration，果然这里有自动配置类-》org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</p>
<p>MybatisAutoConfiguration配置类在当前环境下如果发现DataSource类加载后，会进行自动装配，默认会加载SQLSessionFactory和SqlSessionTemplate，<br>SqlSessionFactory是生产SqlSession的工厂，可以创建Sqlsession(mybatis核心接口，通过这个接口可以执行命令，获取mapper或者是管理事务)<br>SqlsessionTemplate则实现了Sqlsession、DisposableBean接口,在构造方法内创建了一个代理SqlSessionInterceptor，通过该代理类代理执行statement</p>
<p><strong>sqlsession提供的接口方法</strong><br><img src="https://s1.ax1x.com/2020/07/26/apR0x0.png" alt></p>
<p><strong>sqlsessionTemplate类图</strong><br><img src="https://s1.ax1x.com/2020/07/26/apWDfA.png" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/07/05/about-seeking-a-job/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/07/05/about-seeking-a-job/" itemprop="url">谈谈找工作的那些事儿</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-05T13:28:00+08:00">
                2020-07-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="写在最前面"><a href="#写在最前面" class="headerlink" title="写在最前面"></a>写在最前面</h1><p>我是cris,一名毕业于双非二本的后端工程师，说来惭愧，我今年也被动加入了找工作的大军，今年找工作确实是不同于以往，估计也有很多人像博主这样也是因为疫情公司倒闭或者裁员之类的原因在家里待业，鄙人不才，今年花费了79天面了8,9家公司，才收获到2份offer,不过自己还是没能达到自己想要到达的高度，在面试的过程中也发现了自己的很多不足(博主一面试就被问到了自己的知识盲区，博主你的知识盲区怎么这么多啊我摔)，于是写一篇博客记录并以此警醒自己。</p>
<h1 id="关于选择"><a href="#关于选择" class="headerlink" title="关于选择"></a>关于选择</h1><p>这一次，放在博主面前的是两份offer，一个互金，一个央企，博主并没有像之前那样因为薪酬更高选择那份薪水更高的那份互金offer，而是选择了入职央企，其实挺不甘心的，因为今年没能进到大厂，不过自己也确实没有付出太多的努力，想想自己其实也是满惭愧的，身边的同事今年即使是疫情也跳到了一线的互联网大厂，只有我选择了央企，同事大多都不是很理解，因为选择了央企就是选择了稳定，选择了更少的薪酬，选择了更多的业余时间，不过这样就可以去做一些我自己没能完成的事情了吧，其实这里其实是为了博主自己找的借口，还是时间管理的问题，其实在哪工作都一样能学习，都一样能够跳槽去一线的互联网大厂，所以既然选择了，希望博主真的能够刹下心来，在业余时间多学一点东西，把游戏戒掉。</p>
<h1 id="关于现在的工作"><a href="#关于现在的工作" class="headerlink" title="关于现在的工作"></a>关于现在的工作</h1><p>在互联网公司待习惯了，干好自己分内那点事情似乎就已经是必然了，至于产品怎么样，数据怎么样仿佛就跟我一点关系都没有，这样的想法似乎在我的脑子里已经很稀松平常一样，到了央企后，所有的事情似乎都变得不一样了，做了一些原来没有想过的事情，原来不想要做的事情，写文档，画流程图，写ppt，这似乎是以前我最不喜欢做的事情，但转念一想，是不是过去的想法太天真了，过去思考的事情太少了，思维模式需要发生变化了，不应该再只用一个开发的想法去做事，而是以一种统筹的角度来做事情，做一些从前没做过的事情，甚至是做自己不喜欢甚至抵触做的事情，恐怕只有这样，一个人才能够成长吧？</p>
<h1 id="学会系统性成长"><a href="#学会系统性成长" class="headerlink" title="学会系统性成长"></a>学会系统性成长</h1><p>这么回想起来，我已经是第二次体会失业了，想想在不做客户端开发的这些年，在技术上面我好像还是没有太多成长，又开始浑浑噩噩起来，一年工作经验用十年，每次对于自身的提升仿佛都是功利性的，为了找工作而学习，为了找工作而找工作，却忘记了自己学习真正的目的，这样又怎么能够做好技术？怎么能够写出一手好代码呢？当然我学技术并不是只为了能够找到一个开发的岗位，每个月有一定的工资，能够填饱肚子，如果只是这样，那和咸鱼又有什么分别呢？所以，其实这次失业是偶然也是必然，算作对作为一个技术人没有一点点技术上更高层次的追求的一个教训罢了。跟身边优秀的人对比起来，想想自己没能进入大厂其实是必然的，没有转变自己的思维认知，没有对个人的系统性成长，那么这个人又怎么能够拥有核心竞争力呢？</p>
<h1 id="不要放弃自己"><a href="#不要放弃自己" class="headerlink" title="不要放弃自己"></a>不要放弃自己</h1><p>失业时间长不过是自己能力差的表现，永远不要把这个原因归结到环境因素上面。记得前公司的组长曾经“这样”跟我们聊过，“世上无难事，只要肯放弃”，是啊，如果一遇到了难题就选择了逃避，选择了放弃，那么这个人什么时候才能成长呢？今年刷头条，据说有500w北漂因为疫情影响回到了自己的家乡，放弃北漂，其实如果有希望的话，目测谁也不会选择放弃北漂吧，来到北京的北漂们大多有一个能留下的梦，但是在现实面前(高房价，中年危机，刚需结婚)，又有几个人能够继续留下来追梦呢？还记得当年还是在做客户端开发的时候，那是博主第一次体会到了失业的危机感，那时候还没毕业正值毕业季写论文的时候，当时觉得那家公司薪水太低，选择了离开，然后在北京花了1个月时间投简历找工作，然而还是没能找到一份工作，只好回学校一心写毕设。如果博主这次还像毕业时那样放弃了，是不是也就“那样”了？</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>相信有很多像博主一样的朋友，在北京一样迷茫、彷徨着，大家每天做着同一样的北漂梦，当有一天我们不得不离开北京的时候，又或者我们终于实现的北漂的终极梦想的时候，面对自己当年的选择，不要后悔，不要带着遗憾离开！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/06/12/about-reference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/06/12/about-reference/" itemprop="url">谈谈引用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-12T11:05:12+08:00">
                2020-06-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说来惭愧，最近在面试中在JVM基础上面又栽跟头了，尤其是在引用这方面，之前觉得引用这里比较晦涩难懂，枯燥乏味，每次看到JVM中的引用部分内容时，总是会选择性地跳过，所以看起来这次的跌倒是注定的，好，那么废话不多说，我们今天就来尝试弄懂引用这一块内容</p>
<h1 id="何谓引用？"><a href="#何谓引用？" class="headerlink" title="何谓引用？"></a>何谓引用？</h1><p>如果reference类型的数据中存储的数值是另一块内存的起始地址，那么这块内存就代表着一个引用。<br>这种定义就比较纯粹，因为他只能代表被引用或者不被引用两种状态，对于一些“食之无味，弃之可惜”的对象就无能为力了，也就是说我们希望能够描述这样的一类对象:内存空间还足够的时候，则这些对象还可以保存在内存之中，如果内存空间在进行垃圾回收之后还是很紧张，则可以抛弃这些对象，很多系统的缓存功能都符合这种场景，所以在jdk1.2之后，java对引用的概念进行了扩充，将引用分为强引用、弱引用、软引用、虚引用4种，4中引用强度依次减弱<br>(出自深入理解Java虚拟机)</p>
<h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>强引用就是指程序代码中普遍存在的，类似“Object o = new Object();”这类的引用，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象，即便内存不足的时候，虚拟机宁愿抛出内存不足的异常，也不会去回收这些对象<br><strong>使用场景</strong><br>大部分使用场景都是使用了强引用，比如使用new关键字创建对象，通过反射的方式获得一个对象</p>
<h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>软引用是用来描述一些还有用，但是非必需的对象。对于软引用所关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还是没有足够的内存，才会抛出内存溢出异常，jdk1.2之后，提供了SoftReference类来实现软引用</p>
<p><strong>使用场景</strong></p>
<p>有可能在创建后使用的对象，也可能不使用，所以这里基于内存的考虑会使用软引用，常见于缓存方面的使用</p>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>弱引用就是用来描述非必需对象的，但是他的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作的时候，无论当前内存是否足够，都会回收掉只被弱引用所关联的对象，jdk1.2之后，提供了WeakRefrence类来实现弱引用</p>
<p><strong>使用场景</strong><br>弱引用作用于生命周期更短的，对内存更为敏感的场景当中,只要一发生内存回收就会回收掉这部分内存，比如占用内存较大的Map，WeakHashMap,ThreadLocal中的ThreadLocalMap中的key都是弱引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = &quot;hello weak reference&quot;;</span><br><span class="line">WeakReference&lt;String&gt; weakReference = new WeakReference&lt;String&gt;(str);</span><br></pre></td></tr></table></figure>

<h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>虚引用也被称为幽灵引用或者幻影引用，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。也就是在虚引用锁描述的对象被回收之前，会被JVM放入ReferenceQueue中(其他引用是在引用的对象被销毁之后才被传入ReferenceQueue中)，由于这个机制的存在，虚引用大多数被用于引用销毁前的处理工作，另外，虚引用在创建的时候必须带有ReferenceQueue</p>
<p>在jdk1.2之后，提供了PhantomReference类来实现虚引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;String&gt; pref = new PhantomReference&lt;String&gt;(new String(&quot;str&quot;),new ReferenceQueue());</span><br></pre></td></tr></table></figure>

<p><strong>使用场景</strong></p>
<p>对象销毁前的一些操作，比如资源释放等</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/06/04/about-redis-data-structure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/06/04/about-redis-data-structure/" itemprop="url">聊聊redis的底层数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-04T10:42:14+08:00">
                2020-06-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每当我们聊到redis的数据结构的时候，我们总会想到string,hash,set,zet,list,但是我们有没有想过这些数据结构又是怎么实现的呢？今天就来聊一下这些常见的数据结构在底层是怎么实现的</p>
<h1 id="SDS-Simple-Dynamic-String-简单动态字符串"><a href="#SDS-Simple-Dynamic-String-简单动态字符串" class="headerlink" title="SDS(Simple Dynamic String) 简单动态字符串"></a>SDS(Simple Dynamic String) 简单动态字符串</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>在redis中每个sds.h/sdshdr代表一个SDS值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line"><span class="comment">//记录buf数组已使用字节长度</span></span><br><span class="line"><span class="comment">//等于SDS所保存字符串长度</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="comment">//记录buf数组未使用字节长度</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"><span class="comment">//字节数组，用于保存字符串，末尾以'\0'结束 遵循c风格</span></span><br><span class="line"><span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/06/04/t0K2fs.png" alt></p>
<h2 id="不采用C风格字符串的原因"><a href="#不采用C风格字符串的原因" class="headerlink" title="不采用C风格字符串的原因"></a>不采用C风格字符串的原因</h2><ul>
<li>O(1)时间复杂度获取字符串长度,c风格字符串(char数组)需要遍历整个数组的字符进行计数需要O(n)时间复杂度</li>
<li>防止缓冲区溢出和避免手动扩容 使用c风格字符串的时候在对字符串进行修改的时候，比如字符串拼接等等需要自己考虑对字符串数组进行重新扩容，如果忘记扩容会导致与该char数组后的连续内存空间内容被覆盖，会导致一些意想不到的问题，而在使用SDS的时候，API会帮我们检查SDS的空间是否满足所需的修改要求，不满足的话API会自动的将SDS的空间扩展至执行修改所需的大小，所以使用SDS的话既不会产生缓冲区溢出的问题，也不会需要进行手动扩容</li>
<li>确保2进制安全 使用len来确定字符串的长度而不是通过buf数组中的’\0’字符</li>
<li>减少因修改字符串长度时引起的内存重新分配次数(通过内存预分配机制)</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>普通的键值对的键和值都是使用SDS来存储的</li>
<li>AOF缓冲区也是通过SDS来实现的</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表是数据结构中比较常用的一种，可以想到的特性就是O(1)的增删和O(n)的随机访问，redis中的列表就是通过链表来实现的，双向的无环链表，redis构建了自己的链表实现</p>
<h2 id="基本结构-1"><a href="#基本结构-1" class="headerlink" title="基本结构"></a>基本结构</h2><p>链表中的每一个节点使用一个adlist.h/listNode来表示</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="keyword">void</span> *value;</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure>

<p>多个listNode通过prev和next指针组成双端链表，一般情况下只用多个listNode结构就可以组成链表了，如果使用adlist.h/list来持有链表的话，操作起来会比较方便一些</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list &#123;</span><br><span class="line">//头指针</span><br><span class="line">listNode * head;</span><br><span class="line">//尾指针</span><br><span class="line">listNode * tail;</span><br><span class="line">unsigned long len;</span><br><span class="line">//节点值复制函数</span><br><span class="line">void *(*dup)(void *ptr);</span><br><span class="line">//节点值释放函数</span><br><span class="line">void *(*free)(void *ptr);</span><br><span class="line">//节点值对比函数</span><br><span class="line">int (*match)(void *ptr, void *key);</span><br><span class="line">&#125;list</span><br></pre></td></tr></table></figure>

<p>list提供了头尾指针和链表长度计数器len</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>应用于列表，发布与订阅、慢查询、监视器等场景</li>
<li>双端五环链表</li>
<li>每个链表用一个list结构来表示，这个结构带有头尾指针和长度</li>
</ul>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>未完待续<del>~</del></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/06/02/about-sort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/06/02/about-sort/" itemprop="url">聊聊排序算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-02T14:04:05+08:00">
                2020-06-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在平时的编程中，可能会遇到对一组数据进行排序，这个时候我们通常就是调用jdk提供的Arrays.sort()方法来帮助我们进行处理排序，往往并不清楚里面到底做了什么，其实Arrays.sort方法是用了排序算法中的一种，快速排序，那么什么是快速排序？有没有其他类型的排序算法呢？</p>
<h1 id="什么是排序"><a href="#什么是排序" class="headerlink" title="什么是排序"></a>什么是排序</h1><p>在了解排序算法之前，我们先来了解下什么是排序<br>在计算机科学中，一个排序算法是一种能将一串数据按照制定排序方式进行排列的一种算法</p>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>在了解上文提到的快速排序之前，我们先看看有哪些排序算法</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>冒泡排序是一种简单的排序算法，它重复的走访要排序的数列，每次比较两个元素，如果他们顺序错误，则进行交换，走访队列的工作就是重复的进行比较知道没有再需要交换的数据，也就是该数列已经排序完成，这个算法的命名是因为越小的元素会经过交换而慢慢的浮到数列的顶端.<br>冒泡排序对于n个元素的排序需要进行O(n^2)的比较次数，并且可以原地排序</p>
<h3 id="整体工作流程"><a href="#整体工作流程" class="headerlink" title="整体工作流程"></a>整体工作流程</h3><ol>
<li>比较相邻的两个元素，如果第一个比第二个大，就交换他们两个</li>
<li>对每一对相邻元素进行同样的操作，从开始的那一对一直比较到结尾的最后一对，这步完成后最后的元素，将是最大元素</li>
<li>针对所有元素重复以上步骤，除去最后一个元素</li>
<li>每次持续对越来越少的元素执行上述步骤，直到没有任何一对数字需要比较</li>
</ol>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>时间复杂度为O(n^2)</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>O(n) 辅助空间O(1)</p>
<h3 id="最优时间复杂度"><a href="#最优时间复杂度" class="headerlink" title="最优时间复杂度"></a>最优时间复杂度</h3><p>正序有序数列<br>O(n^2)</p>
<h3 id="最差时间复杂度"><a href="#最差时间复杂度" class="headerlink" title="最差时间复杂度"></a>最差时间复杂度</h3><p>逆序有序数列<br>O(n^2)</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数组</p>
<h3 id="是否稳定"><a href="#是否稳定" class="headerlink" title="是否稳定"></a>是否稳定</h3><p>是</p>
<h3 id="一些可以优化的点"><a href="#一些可以优化的点" class="headerlink" title="一些可以优化的点"></a>一些可以优化的点</h3><p>如果冒泡排序在对一个有序队列进行排序的话，那么在一趟排序下来必定没有发生任何一次交换，反过来说也成立，如果一趟排序中没有发生任何一次交换，则说明队列就是有序的，那么这时候我们只需要引入一个标志，如果一趟排序没有交换发生，我们就可以退出循环，不再需要执行后续的循环了，这样可以使得冒泡排序在最优场景正序有序的数据场景，时间复杂度降为O(n)</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>插入排序是一种简单直观的排序算法，它的工作原理是构建有序队列，对于未排序的数据，会在已排序的队列中从后向前进行反向扫描，找到相应的位置并进行插入，插入排序在实现上只需用O(1)的额外空间，因此在从后向前的扫描的过程中，需要反复将已排序元素逐步向后挪位，从而为新元素提供插入空间。<br>这个过程和我们平时打扑克的时候，将牌进行一步步排序的过程比较相似，拿到一张牌的时候，我们先认为手中的牌堆是有序的，然后新抓的牌在牌堆里面找到合适的位置并进行插入，反复抓牌并重复该过程，直至牌抓完，手中的牌也就成了有序的</p>
<h3 id="整体工作流程-1"><a href="#整体工作流程-1" class="headerlink" title="整体工作流程"></a>整体工作流程</h3><ol>
<li>从第一个元素开始，该元素被认定为已经有序</li>
<li>取出下一个元素，在已经排序的元素中从后向前进行扫描</li>
<li>如果该已排序的元素大于刚才取出的元素，则将该元素进行后移</li>
<li>重复步骤3，直到找到已排序的元素中小于或等于新元素的位置</li>
<li>将新元素插入到该位置</li>
<li>重复步骤2-5</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选定第一位为已排序数列，从下一个元素开始排序,并逐个对新加入元素(数组后面元素)进行插入排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> newElement = data[i];</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//从后向前扫描,如果新插入的元素比已排序队列的待比较元素要小，则后移该元素</span></span><br><span class="line">            <span class="comment">//若新插入的元素比带比较元素大，则证明已经找到该元素的位置</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; newElement &lt; data[j]) &#123;</span><br><span class="line">                data[j + <span class="number">1</span>] = data[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将该元素插入到该位置</span></span><br><span class="line">            data[j + <span class="number">1</span>] = newElement;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(n^2)</p>
<h3 id="最优时间复杂度-1"><a href="#最优时间复杂度-1" class="headerlink" title="最优时间复杂度"></a>最优时间复杂度</h3><p>正序有序<br>O(n)</p>
<h3 id="最差时间复杂度-1"><a href="#最差时间复杂度-1" class="headerlink" title="最差时间复杂度"></a>最差时间复杂度</h3><p>逆序有序<br>O(n^2)</p>
<h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>数组</p>
<h3 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>O(n) 辅助空间 O(1)</p>
<h3 id="是否稳定-1"><a href="#是否稳定-1" class="headerlink" title="是否稳定"></a>是否稳定</h3><p>是</p>
<h3 id="一些可以优化的点-1"><a href="#一些可以优化的点-1" class="headerlink" title="一些可以优化的点"></a>一些可以优化的点</h3><p>由于插入排序在已排序队列中找自己的位置的时候是逐次比较的，由于该队列是有序的，那么这里其实可以简单的进行一个优化，在找位置的时候可以通过二分查找法来进行减少比较次数，但是由于交换次数不变，算法的时间复杂度依旧是O(n^2)</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>选择排序是一种简单直观的排序算法，它的工作原理大致如下，首先在未排序的数据中找最大或者最小的元素，存放到排序队列的起始位置，然后再从剩余未排序的元素中寻找最大或者最小元素，然后放在已排序队列的队尾，以此类推，直到所有的元素均排序完毕</p>
<p>选择排序的优点主要跟数据移动有关，如果某个数据已经位于正确的位置上面，则它不会进行移动，选择排序每次交换一对元素，它们之中至少有一个将被移到其最终位置上面，因此对n个元素的表进行排序的话，只会涉及到至多n-1次交换，在所有完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p>
<p>交换操作比比较所需要的CPU较少，而选择排序比冒泡排序交换次数要少，所以当空间复杂度要求较高的时候，可以考虑选择排序，实际适用的场景相当罕见</p>
<h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(n^2)</p>
<h3 id="最优时间复杂度-2"><a href="#最优时间复杂度-2" class="headerlink" title="最优时间复杂度"></a>最优时间复杂度</h3><p>正序有序<br>O(n^2)</p>
<h3 id="最差时间复杂度-2"><a href="#最差时间复杂度-2" class="headerlink" title="最差时间复杂度"></a>最差时间复杂度</h3><p>逆序有序<br>O(n^2)</p>
<h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><p>数组</p>
<h3 id="空间复杂度-2"><a href="#空间复杂度-2" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>O(n) + 辅助空间O(1)</p>
<h3 id="是否稳定-2"><a href="#是否稳定-2" class="headerlink" title="是否稳定"></a>是否稳定</h3><p>不稳定</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>快速排序，又称分区交换排序，简称快排，在需要对n个元素进行排序的时候需要O(nlogn)次比较，最坏的时候需要O(n^2)次比较，但这并不常见</p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol>
<li>从数列中挑选一个基准值(通常会选定起始元素)</li>
<li>对数列进行分割，将所有小于基准值的放在基准值左侧，大于基准值的元素放在基准值右侧</li>
<li>递归地对基准值两侧的队列重复1,2步骤</li>
</ol>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> head, <span class="keyword">int</span> tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> startIndex = head;</span><br><span class="line">        <span class="keyword">int</span> endIndex = tail;</span><br><span class="line">        <span class="comment">//递归终止条件，如果分区中元素只有 0 或1 个则已经有序</span></span><br><span class="line">        <span class="keyword">if</span> (tail - head &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> selectedElement = data[startIndex];</span><br><span class="line">        <span class="keyword">if</span> (head &lt; tail) &#123;</span><br><span class="line">            <span class="comment">//按基准值进行分区,左面的分区都小于等于基准值,右面的分区都大于基准值</span></span><br><span class="line">            <span class="keyword">while</span> (head &lt; tail) &#123;</span><br><span class="line">                <span class="comment">//从右向左找第一个小于等于基准值的元素</span></span><br><span class="line">                <span class="keyword">if</span> (data[tail] &lt;= selectedElement) &#123;</span><br><span class="line">                    <span class="comment">//找到后，再从左至右找第一个大于基准值的元素，并交换它们</span></span><br><span class="line">                    <span class="keyword">if</span> (data[head] &gt; selectedElement) &#123;</span><br><span class="line">                        swap(data, head, tail);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        head++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tail--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//head和tail指针重合,此时说明除了指针处所有元素已经交换完毕,则交换基准值和head指针处元素</span></span><br><span class="line">            swap(data, startIndex, head);</span><br><span class="line">            <span class="comment">//分区后对左右两个子分区进行递归，重复上述操作</span></span><br><span class="line">            sort(data, startIndex, head - <span class="number">1</span>);</span><br><span class="line">            sort(data, head + <span class="number">1</span>, endIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> head, <span class="keyword">int</span> tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data[head] &gt; data[tail]) &#123;</span><br><span class="line">            <span class="comment">//对两个元素进行交换</span></span><br><span class="line">            data[head] = data[head] + data[tail];</span><br><span class="line">            data[tail] = data[head] - data[tail];</span><br><span class="line">            data[head] = data[head] - data[tail];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(nlogn)</p>
<h3 id="最优时间复杂度-3"><a href="#最优时间复杂度-3" class="headerlink" title="最优时间复杂度"></a>最优时间复杂度</h3><p>O(nlogn)</p>
<h3 id="最差时间复杂度-3"><a href="#最差时间复杂度-3" class="headerlink" title="最差时间复杂度"></a>最差时间复杂度</h3><p>O(n^2)</p>
<h3 id="空间复杂度-3"><a href="#空间复杂度-3" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>快速排序所使用的空间，需要依照使用的版本决定。使用原地分割的快速排序版本，在任何递归调用前都会使用固定的额外空间，如果需要产生O(logn)次嵌套递归调用，则需要O(logn)的空间</p>
<h3 id="是否稳定-3"><a href="#是否稳定-3" class="headerlink" title="是否稳定"></a>是否稳定</h3><p>否</p>
<h3 id="一些可以优化的点-2"><a href="#一些可以优化的点-2" class="headerlink" title="一些可以优化的点"></a>一些可以优化的点</h3><p>基准值选定问题，如果待排序数据是乱序的，基准值是第一个或者最后一个都没问题，但是如果是已经排好序的数据，如果选定第一个或者最后一个为基准值，分区的时候就会出现基准值分区后，只有一个分区有元素</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>希尔排序，可以称为递减增量的排序算法，是插入排序的一种高效的改进版本<br>希尔排序是基于插入排序以下两点性质提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序(正序有序)的数据操作时，操作效率高，可以达到线性排序的效率(O(n))</li>
<li>插入排序一般来说是低效的，因为插入排序每次只能向前移动一位</li>
</ol>
<p>希尔排序实际上是一个分组排序的过程，每一次通过一个步长对整个数列进行分组，对每个分组内的数据进行插入排序，然后缩小步长，再对每个分组内的数据进行插入排序，直到最后每个分组内的元素只有一个的时候，对该数列的排序演变为普通的插入排序，此时的数列经过方才的过程已经几乎接近有序队列，这时候再使用插入排序效率几乎能达到插入排序的最优时间复杂度即线性排序</p>
<p>在数量较少的时候，希尔排序甚至比堆排序和快速排序要快，但是涉及到大量数据的时候希尔排序还是要比快速排序要慢</p>
<h3 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h3><ol>
<li>选定步长，并建立分组</li>
<li>对每一个分组进行插入排序操作</li>
<li>将步长按照一定的规则进行处理，这里步长规则选为每次除以2</li>
<li>重复步骤1 2 直至步长变为最小步长1</li>
<li>步长变为1时 对数列的排序演变为普通插入排序，此时数列接近有序，通过最后一遍普通插入排序后所得数列即变为有序队列</li>
</ol>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void sort(int[] data) &#123;</span><br><span class="line">        //对数列按照gap进行分组,当gap&gt;=1时,对每组元素进行插入排序</span><br><span class="line">        for (int gap = data.length /2; gap &gt;= 1; gap/=2) &#123;</span><br><span class="line">            //分组遍历处理</span><br><span class="line">            int groups = data.length / gap;</span><br><span class="line">            for (int i = 0; i &lt;= groups; i++) &#123;</span><br><span class="line">                //对每一组中的元素进行插入排序</span><br><span class="line">                insertSortAlgorithm.sort(data,i,gap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">//insertSortAlgorithm.sort()</span><br><span class="line">public void sort(int[] data,int start, int gap) &#123;</span><br><span class="line">        for (int i = start + gap; i &lt; data.length; i += gap) &#123;</span><br><span class="line">            int newElement = data[i];</span><br><span class="line">            int j = i - gap;</span><br><span class="line">            while (j &gt;= 0 &amp;&amp; newElement &lt; data[j]) &#123;</span><br><span class="line">                data[j + gap] = data[j];</span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            data[j+gap] = newElement;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="平均时间复杂度"><a href="#平均时间复杂度" class="headerlink" title="平均时间复杂度"></a>平均时间复杂度</h3><p>根据步长序列选定规则决定 </p>
<h3 id="最优时间复杂度-4"><a href="#最优时间复杂度-4" class="headerlink" title="最优时间复杂度"></a>最优时间复杂度</h3><p>O(n)</p>
<h3 id="最差时间复杂度-4"><a href="#最差时间复杂度-4" class="headerlink" title="最差时间复杂度"></a>最差时间复杂度</h3><p>根据步长序列选定规则决定 </p>
<table>
<thead>
<tr>
<th>步长选定规则</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>n /2^i</td>
<td>O(n^2)</td>
</tr>
<tr>
<td>2^k -1</td>
<td>O(n^3/2)</td>
</tr>
<tr>
<td>2^i * 3^j</td>
<td>O(nlog^2n)</td>
</tr>
</tbody></table>
<h3 id="是否稳定-4"><a href="#是否稳定-4" class="headerlink" title="是否稳定"></a>是否稳定</h3><p>不稳定</p>
<p>未完待续——</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><h3 id="时间复杂度-4"><a href="#时间复杂度-4" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><h3 id="是否稳定-5"><a href="#是否稳定-5" class="headerlink" title="是否稳定"></a>是否稳定</h3><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><h3 id="时间复杂度-5"><a href="#时间复杂度-5" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><h3 id="是否稳定-6"><a href="#是否稳定-6" class="headerlink" title="是否稳定"></a>是否稳定</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/05/18/about-micro-services/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/05/18/about-micro-services/" itemprop="url">聊聊微服务</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-18T15:19:37+08:00">
                2020-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是微服务？它有哪些特点？"><a href="#什么是微服务？它有哪些特点？" class="headerlink" title="什么是微服务？它有哪些特点？"></a>什么是微服务？它有哪些特点？</h1><p>微服务是一种软件架构风格，他是以专注于单一职责与功能的小型功能模块为基础，利用模块化的方式组合成大型的复杂应用程序，各功能模块使用与语言无关的API相互通信 —-wikipedia</p>
<p>微服务架构 将单体应用拆分为多个高内聚低耦合的小型服务，每个小服务运行在独立进程，由不同的团队进行开发和维护，服务间采用轻量级通信机制，独立自动部署，可以采用不同的技术进行开发和使用独立的存储空间</p>
<h2 id="微服务的特点"><a href="#微服务的特点" class="headerlink" title="微服务的特点"></a>微服务的特点</h2><ul>
<li>每个微服务仅对单个业务负责，且为该业务的功能负责</li>
<li>每个微服务独立进行部署，不需要依赖其他微服务及相关资源，如数据库缓存等</li>
<li>服务可替代,每个微服务原则上都可以使用不同的语言、框架进行实现，且更换技术实现的微服务对整个业务系统不会造成影响</li>
<li>每个微服务拥有单独的数据存储</li>
<li>每个微服务由小团队进行维护，服务以业务来进行拆分后，每个微服务将有人数不多的团队对其进行维护</li>
</ul>
<h1 id="为什么要用微服务？"><a href="#为什么要用微服务？" class="headerlink" title="为什么要用微服务？"></a>为什么要用微服务？</h1><p>为什么要用微服务，实际上就是每一种架构它的实际的使用场景是怎样的，或者说微服务架构它是为了解决哪些问题而诞生的呢？要聊这个内容实际上就要从单体应用开始讲</p>
<p>什么是单体应用呢?</p>
<p>单体应用就是将应用的所有功能都打包成一个独立的单元，最终以一个WAR或jar存在。</p>
<p>那么单体应用有哪些优点和缺点呢？</p>
<p>单体应用的优点:</p>
<ul>
<li>便于开发 只需借助IDE的开发调试功能即可完成</li>
<li>易于测试 通过单元测试或者浏览器即可测试</li>
<li>易于部署 打包成单一jar包或者war包，执行jar即可部署</li>
</ul>
<p>缺点:</p>
<ul>
<li>复杂性高   随着业务的迭代，项目中的代码会急剧增多，项目模块也会随之增加，模块间的关系变得更加复杂，整个项目变得非常复杂，在</li>
<li>可靠性差  一体化应用某块业务发生改变后，就需要整体重新测试、部署、很容易某个业务模块牵一发而动全身导致整个应用不可用， 微服务则很好的解决了这个问题，某个服务不可用仅仅是影响它自己这一个微服务</li>
<li>扩展性差  一体化应用只能通过在负载均衡器后面放置多个整个应用实例的整体进行水平扩展，非常笨重，而微服务则则可以根据需要对某个微服务进行按需缩放或者扩展</li>
<li>部署或者启动时间变长   </li>
<li>交付时间长 微服务架构中 假定我们有100个服务，如果有一个服务中的业务发生了变化，则只需要对这一个服务进行迭代，测试、上线，而不是部署整个应用</li>
</ul>
<p>其实引入微服务就是为了解决单体应用中的这些缺点而产生的</p>
<h1 id="微服务架构带来了哪些问题"><a href="#微服务架构带来了哪些问题" class="headerlink" title="微服务架构带来了哪些问题?"></a>微服务架构带来了哪些问题?</h1><h2 id="服务数量成倍增长-维护难度加大"><a href="#服务数量成倍增长-维护难度加大" class="headerlink" title="服务数量成倍增长 维护难度加大"></a>服务数量成倍增长 维护难度加大</h2><p>在引入微服务架构后，由单体应用拆分出来的按业务职责划分的服务不可避免的爆炸式增长，使用传统方式运维，无疑就是灾难，这就使得微服务的基石–持续集成在拆分服务之前是必须解决的问题</p>
<h2 id="复杂性提高，学习成本提高"><a href="#复杂性提高，学习成本提高" class="headerlink" title="复杂性提高，学习成本提高"></a>复杂性提高，学习成本提高</h2><p>由于引入了新技术，开发人员不得不从头开始学起这些新的内容，尤其是像引入微服务后，这就不可避免的带来了分布式的问题，比如分布式事务、业务体量上来之后，当数据库成为瓶颈后，可能不得不涉及到数据库层面的一些优化，比如分库分表的问题、分库分表之后又带来一些问题、分库分表后唯一主键问题，还有可能涉及到数据迁移的问题和全局表问题，这一系列的问题都是在引入微服务这一体系之后带来的问题，对于这个问题来说，只能说微服务它本身解决了一些问题，它带来的问题，我们可以再找一些别的方式去做处理，我也相信微服务它本身带来的好处要比它带来的复杂性要好的多，所以说对于增加的员工的学习成本来说，微服务是一种趋势，只能说“拥抱变化”了~</p>
<h2 id="请求链路长-问题排查成本较高"><a href="#请求链路长-问题排查成本较高" class="headerlink" title="请求链路长 问题排查成本较高"></a>请求链路长 问题排查成本较高</h2><p>引入微服务后，经常会发现，某个服务出现问题，有可能并不是它自身原因导致的，有可能是它的某个下游服务出了问题，当我们逐级排查的时候，调用链路特别长的情况下，找到最根上的出问题的那个节点才能找到真正出问题的节点在哪里，就好比如果生产环境出了问题，这就会导致我们排查问题可能非常的耗时，我们都知道，生产问题尽早排查，尽快排查出问题的根本原因，尽快地修复问题，我们的损失就会越小，所以这个时候就不得不引入”链路追踪”,链路追踪就是把我们涉及到的每一次请求调用了哪些服务，调用的顺序、调用的层级关系以及每次调用花费的时间搞清楚，把这些内容串起来从而通过调用链快速定位到底是哪里出了问题。</p>
<p>未完待续—</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/05/11/about-lock-of-java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/05/11/about-lock-of-java/" itemprop="url">聊聊Java中的锁</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-11T17:03:14+08:00">
                2020-05-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>锁机制不仅仅是面试中是一个很高频的面试问题，而且是我们开发中不得不了解的一个内容，今天我们就来聊聊Java中的各中锁</p>
<h1 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h1><h1 id="共享锁-VS-排他锁"><a href="#共享锁-VS-排他锁" class="headerlink" title="共享锁 VS 排他锁"></a>共享锁 VS 排他锁</h1><p>共享锁和排它锁是针对锁的共享这方面来说的，即共享锁是可以被多个线程共享的，而排它锁不是</p>
<h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>共享锁又被称为读锁，可以被多个线程所持有，如果线程A对共享资源T加了共享锁，则线程A只能读取共享资源T，并不能对其进行修改，其他线程只能对共享资源T加共享锁，不能加排它锁</p>
<h2 id="排它锁"><a href="#排它锁" class="headerlink" title="排它锁"></a>排它锁</h2><p>排它锁又被称为写锁，如果线程A对共享资源T加了排它锁，则线程A既能对共享资源T读又能进行写操作，其他线程不能对共享资源T加任何类型的锁，其中JDK中的synchronized和Lock中写锁的实现类都是排它锁</p>
<h1 id="自旋锁-VS-自适应自旋锁"><a href="#自旋锁-VS-自适应自旋锁" class="headerlink" title="自旋锁 VS 自适应自旋锁"></a>自旋锁 VS 自适应自旋锁</h1><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁实际上是按照在线程获取锁失败的时候是否会是否挂起该线程来划分的，自旋锁是指在线程获取共享资源的时候获取锁失败了，认为等一小会儿(进行固定次数的自旋)，就可以获得该资源的锁，而不是通过CPU阻塞线程，切换线程的时间片这种方式，通常情况下这比CPU进行线程切换(涉及到用户态和内核态的转换)的开销要小得多，如果自旋完成后，前面锁定资源的线程已经释放了锁，那么当前线程可以拿到锁，不过这是一个不太确定的情况，有可能自旋完成后，前面的线程还没有释放该资源锁。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程可能只是浪费CPU的时间片，所以自旋的等待时间需要有一定的限度，如果自旋超过了限定次数，没有获得资源锁，就应该挂起线程。</p>
<p>自旋是通过CAS实现的，类似AtomicInteger中调用unsafe进行自增(do-while循环)就是一个自旋操作，如果修改失败就通过循环修改值，直至修改成功</p>
<h2 id="自适应自旋锁"><a href="#自适应自旋锁" class="headerlink" title="自适应自旋锁"></a>自适应自旋锁</h2><p>自适应自旋锁是在自旋锁上面进行的改进，它的自旋时间不再是固定值，而是由在同一个自旋锁上一次的自选时间和拥有者的状态来决定的，如果同一个锁对象上，刚刚成功获取过锁，则虚拟机认定它很有可能再次成功，那么它的自旋时间可以允许变得更长，反之则更短</p>
<h1 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h1><p>可重入锁又被称为是递归锁，是指同一个线程在外层方法已经拿到锁的情况下，在进入内层方法的时候就会自动拿到锁，java中的Synchronized和ReentrantLock都是可重入锁，可重入锁在一定程度上可以避免死锁的发生。</p>
<p>比如类A有两个实例方法C,D，这两个方法都被sychronized修饰，在C方法内部调用了D，那么某一个线程在进入C已经拿到锁的情况下进入D方法就会自动拿到锁</p>
<h1 id="无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h1><p>这些锁实际上是按照锁的状态来区分，并且是专门针对synchronized关键字来说的，但是在对这四种锁描述之前需要对一些概念进行了解:对象头和Monitor</p>
<h2 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h2><p>Hotspot虚拟机中，对象在虚拟机中的布局分为3部分，分别是对象头、实例数据、对齐填充<br>普通对象的对象头包括两部分:MarkWord和ClassMetaData Address(类型指针)，如果是数组对象还额外包括一个额外的数组长度部分</p>
<p><strong>Markword</strong><br>用于存储对象自身的运行数据，如HashCode,GC分代年龄，锁状态标志，线程持有的锁、偏向线程ID,偏向时间戳等等，占用内存大小跟虚拟机位长一致<br><strong>Kclass Pointer</strong><br>类型指针，指向对象的类元数据，虚拟机通过这个指针确定该对象是哪个类的实例</p>
<p><strong>Array Length</strong><br>数组长度</p>
<p>对象需要存储的数据很多，这已经超出了32bit或者是64bit能表示的限度，此外对象头信息是对象自定义的数据无关的额外存储成本，在考虑虚拟机空间效率的时候，MarkWord被设计成一个非固定的数据结构用来在极小的空间里面存储尽量多的信息，它会根据对象的状态复用自己的存储空间，也就是说MarkWord中存储的内容会伴随着锁的状态变化而变化。</p>
<p>例如在32bit的hotspot的虚拟机中，其各个锁状态下的存储内容如下所示</p>
<p><img src="https://s1.ax1x.com/2020/05/11/YYNgrn.jpg" alt><br>图片引用自<a href="https://blog.csdn.net/u010723709/article/details/50341631" target="_blank" rel="noopener">Synchronized与三种锁态</a></p>
<p><strong>Monitor</strong><br>Monitor可以理解为一个同步工具或一种同步机制。每一个Java对象都有一个看不见的锁，称为内部锁或Monitor锁，这个Monitor锁实际上就存在于对象的对象头中，对象头中的若干标志位用于标识锁的锁定状态和被哪个线程拥有，在一个线程需要使用一个对象之前，需要先获得它的内置锁，使用之后还需要释放这个内置锁，在使用过程中其它线程无法获取这个锁。 </p>
<p><strong>Synchronized概述</strong><br>Synchronized在JVM里面的实现是基于进入和退出Monitor对象来获取对象锁从而实现方法同步和代码块同步，不同虚拟机的实现细节可能不一样，但都可以通过成对的MonitorEnter和MonitorExit指令来实现，而MonitorEnter和MonitorExit的执行是通过调用操作系统的互斥原语Mutex Lock来实现的，被阻塞的线程会被挂起等待重新调度，会导致CPU在用户态和内核态两个态之间进行切换，比较耗性能，这也是为什么大家对synchronized的一贯印象就是性能较差的原因，jdk在1.6之后对sychronized进行了一系列调整，后来实际上跟Lock的性能不相上下，其实默认还是推荐用synchronized的，语义清晰、操作简单、无需手动关闭</p>
<p>同步方法是通过ACC_SYNCHRONIZED标识符来实现同步的<br>同步代码块是通过MonitorEnter和MonitorExit两个指令来实现的</p>
<p><strong>MonitorEnter</strong><br>插入在同步代码块的起始位置，当代码执行到该指令时，将会尝试获取该对象的monitor的所有权，即尝试获取该对象的锁<br><strong>MonitorExit</strong><br>MonitorExit插入在方法结束和异常处，JVM保证每个MonitorEnter必须有相应的MonitorExit</p>
<h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2><p>无锁没有对共享资源进行锁定，所有的线程都能访问并修改资源，但是只有一个线程能修改成功，如果多个线程同时修改同一个值，一定会有一个线程会成功，其他修改失败的线程会不断重试(自旋)直到修改成功，这种无锁的情况实际上适用于竞争度不高(读多写少)的情况下，这样自旋一会儿就能获取到资源的修改权，否则自旋非常浪费CPU资源</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Hotspot虚拟机的作者发现在大多数情况下不仅不存在锁的竞争，甚至锁总是同一个线程多次获得，所以为了降低获取锁的代价而引入了偏向锁。偏向锁就是指一段代码一直被一个线程访问，那么线程会自动获取锁，直接执行同步代码块，从而降低获取锁的代价</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>只有一个线程进入临界区</p>
<h3 id="锁的获取"><a href="#锁的获取" class="headerlink" title="锁的获取"></a>锁的获取</h3><ol>
<li>获取对象的markword</li>
<li>检测MarkWord是否为可偏向状态</li>
<li>如果为可偏向，并且markword中指向的线程是当前线程则执行同步代码</li>
<li>如果为可偏向，但指向的线程不是当前线程，通过cas竞争，若竞争成功，则执行同步代码，如果不成功执行5</li>
<li>偏向锁竞争不成功，证明存在多线程竞争情况，此时偏向锁不再适用，到达全局安全点，获得偏向锁的线程将被挂起，偏向锁升级为轻量级锁，被阻塞在安全点的线程继续往下执行同步代码</li>
</ol>
<h3 id="锁的释放"><a href="#锁的释放" class="headerlink" title="锁的释放"></a>锁的释放</h3><p>线程拥有的偏向锁并不会主动释放，需要等待其他线程来竞争，偏向锁的撤销需要等待全局安全点(没有正在执行的代码的时间点),步骤如下</p>
<ul>
<li>判断锁对象是否还处于锁定的状态，如果否，则将其恢复到无锁状态，允许其它线程竞争，如果还处于锁定状态，则挂起拥有偏向锁的线程，并将指向该线程的lock record的指针放入对象头的mark word中，升级为轻量级锁(00),然后恢复刚才拥有偏向锁的线程，进入轻量级锁的竞争模式</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>如果存在锁的竞争，会带来锁撤销的消耗</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>当锁是偏向锁的时候，被其他线程访问出现锁的竞争的时候，就会升级为偏向锁，或者显式关闭偏向锁(jdk1.6以后默认开启，并且默认加的是偏向锁，显式关闭后，默认加的就是轻量级锁),其他线程会通过自旋的方式尝试获取锁，不会阻塞，从而提高性能，一般来说，轻量级锁认为竞争存在，但是竞争的程度较轻，一般两个线程对同一个锁的操作都会错开，或者一个没有拿到锁的线程稍微自旋一会儿就可以拿到锁，如果超过一定自旋的次数后还是没有拿到锁，或者一个线程持有锁，一个线程在自旋的时候，这时候又有第三个线程来竞争锁的时候，轻量级锁就会升级为重量级锁</p>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>多个线程交替进入临界区，同步代码执行速度较快</p>
<h4 id="锁的获取-1"><a href="#锁的获取-1" class="headerlink" title="锁的获取"></a>锁的获取</h4><ol>
<li>判断当前对象是否为无锁状态(是否为偏向锁位0，锁标志位01)，若是,JVM会在当前线程的栈帧中建立一个名为Lock Record的空间，用于存储锁对象目前MarkWord的拷贝</li>
<li>将对象头中的MarkWord拷贝到LockRecord中</li>
<li>拷贝成功后，JVM利用CAS尝试将对象头中MarkWord中设置为指向LockRecord的指针,如果成功执行4，否则执行5</li>
<li>更新成功，这个线程就拥有了这个对象的锁，并且将对象MarkWord的标志位转为00，表示此对象处于轻量级锁状态</li>
<li>更新失败，虚拟机会检查对象头中MarkWord是否指向当前线程的栈帧，如果是，代表当前线程已经获取到了这个对象的锁，可以直接执行同步代码，否则自旋执行步骤3，如果自旋结束还没有获得锁，则说明锁的竞争比较激烈，需要膨胀为重量级锁，将MarkWord里面的锁标志位置为10，MarkWord里面这时存放的是重量级锁的指针<h4 id="锁的释放-1"><a href="#锁的释放-1" class="headerlink" title="锁的释放"></a>锁的释放</h4></li>
<li>使用CAS用线程中MarkWord的拷贝替换对象头中的MarkWord,替换成功则执行2，否则执行3</li>
<li>替换成功，则锁释放成功，整个同步过程完成，对象恢复到无锁的状态</li>
<li>替换失败，说明有其他线程正在竞争锁，在释放锁的同时，唤醒被挂起的线程<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4></li>
</ol>
<p>始终得不到锁的线程，自旋会消耗CPU资源，造成浪费</p>
<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>重量级锁依靠对象的Monitor锁实现，而Monitor锁又依赖操作系统的Mutex Lock(互斥锁)来实现的</p>
<ul>
<li>在同步代码块中，jvm通过monitorenter和monitorexit实现同步锁的获取和释放。</li>
<li>monitorenter在编译后插入到同步代码块的起始位置，monitorexit被插入到方法结束和异常处。</li>
<li>线程执行monitorenter的时候会尝试获取对象对应的monitor的所有权，即尝试获对象锁<br>线程执行monitorexit的时候将会把进入次数-1直到进入次数为0的时候释放锁</li>
<li>同一时刻只有一个线程能够成功，其他失败的线程会放弃锁的竞争被阻塞，放到同步队列中并且等待锁的释放，状态变为Blocked状态，当这个对象锁被释放的时候，会通知队列中等待这个对象锁的线程，使其可以重新竞争锁</li>
</ul>
<h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>多个线程同时进入临界区，同步代码执行时间较长</p>
<h1 id="Synchronized用法"><a href="#Synchronized用法" class="headerlink" title="Synchronized用法"></a>Synchronized用法</h1><h2 id="修饰实例方法"><a href="#修饰实例方法" class="headerlink" title="修饰实例方法"></a>修饰实例方法</h2><p>获取的是对象锁，锁住的是类的实例对象</p>
<h2 id="修饰静态方法"><a href="#修饰静态方法" class="headerlink" title="修饰静态方法"></a>修饰静态方法</h2><p>被锁住的是类的class对象</p>
<h2 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h2><p>被锁住的是实例对象</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="https://tech.meituan.com/2018/11/15/java-lock.html" target="_blank" rel="noopener">不可不说的Java“锁”事</a></p>
<p><a href="https://blog.csdn.net/u013256816/article/details/51204385" target="_blank" rel="noopener">Java中的锁</a></p>
<p><a href="https://blog.csdn.net/qq_42862882/article/details/89375340" target="_blank" rel="noopener">JAVA锁优化和膨胀过程</a><br><a href="https://juejin.im/post/5ae6dc04f265da0ba351d3ff#heading-14" target="_blank" rel="noopener">彻底理解synchronized</a><br><a href="https://juejin.im/post/5abc9de851882555770c8c72#heading-14" target="_blank" rel="noopener">Java 8 并发篇 - 冷静分析 Synchronized（下）</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kyo7701.github.io/blog/blog/2020/05/08/about-java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="mr_cris">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cris's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/blog/2020/05/08/about-java/" itemprop="url">java基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-08T10:49:49+08:00">
                2020-05-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java基础之集合类"><a href="#Java基础之集合类" class="headerlink" title="Java基础之集合类"></a>Java基础之集合类</h1><h1 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h1><p>Collection接口继承自Iterable接口，Iterable接口允许使用foreach方式遍历，并且定义了一个迭代器</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>List接口继承自Collection接口，存储一组<strong>不唯一</strong>的<strong>有序</strong>(插入序)的对象。<br>采用线性列表存储，长度可以动态改变，可以通过索引访问</p>
<h3 id="ArrayList-和LinkedList区别"><a href="#ArrayList-和LinkedList区别" class="headerlink" title="ArrayList 和LinkedList区别"></a>ArrayList 和LinkedList区别</h3><p>ArrayList底层用数组实现，随机访问效率高(O(1)),插入删除效率低(O(n),需要移动后面元素)<br>LinkedList底层用链表实现，随机访问效率低(O(n)),插入删除效率高(O(1))</p>
<h3 id="ArrayList-和vector的区别"><a href="#ArrayList-和vector的区别" class="headerlink" title="ArrayList 和vector的区别"></a>ArrayList 和vector的区别</h3><p>Vector的所有方法都是同步方法,而ArrayList不是，如果需要用到线程安全的list可以考虑用Vector，不过即使需要用线程安全的list我们也是推荐用CopyOnWriteList而不是用Vector</p>
<h3 id="ArrayList是否是线程安全的？"><a href="#ArrayList是否是线程安全的？" class="headerlink" title="ArrayList是否是线程安全的？"></a>ArrayList是否是线程安全的？</h3><p>非线程安全，如果需要线程安全，可以使用Vector或者CopyOnWriteList</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><h3 id="HashSet是如何去重的"><a href="#HashSet是如何去重的" class="headerlink" title="HashSet是如何去重的?"></a>HashSet是如何去重的?</h3><p>HashSet底层是通过HashMap实现的，HashSet中的元素放在HashMap中的K上面，我们都知道HashMap中的K是不重复的，内容相同的对象hashCode是相同的(HashCode决定元素存储在HashMap中Entry数组中的位置)，并且如果equals方法返回对象是相同的话默认会覆盖Value内容，但其实这里对Hashset来讲value覆盖与否都无所谓(hashset中放入的是PRENSENT对象每次都一样)，因为关注的是hashmap中的k</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h3 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h3><ul>
<li>HashTable是线程安全的(所有方法被sychronized修饰)，HashMap不是</li>
<li>HashTable不允许有空的key和value，HashMap可以</li>
</ul>
<h3 id="HashMap是否是线程安全的-如果在多线程环境下并发访问会不会有问题？"><a href="#HashMap是否是线程安全的-如果在多线程环境下并发访问会不会有问题？" class="headerlink" title="HashMap是否是线程安全的?如果在多线程环境下并发访问会不会有问题？"></a>HashMap是否是线程安全的?如果在多线程环境下并发访问会不会有问题？</h3><p>HashMap不是线程安全的，jdk1.7的时候HashMap在多线程下并发增加元素扩容的时候会出现环形链表，导致死循环，jdk1.8的时候采用尾插法解决了环形链表的问题，不过还是非线程安全的</p>
<h3 id="HashMap底层是怎么实现的"><a href="#HashMap底层是怎么实现的" class="headerlink" title="HashMap底层是怎么实现的?"></a>HashMap底层是怎么实现的?</h3><p>HashMap在jdk1.7版本的时候是通过数组+链表的方式实现的,在jdk1.8里面引入了红黑树，在使用拉链法解决hash碰撞的时候，链中元素超过8的时候会转为红黑树</p>
<h3 id="红黑树和二叉排序树、AVL树的区别-延伸话题"><a href="#红黑树和二叉排序树、AVL树的区别-延伸话题" class="headerlink" title="红黑树和二叉排序树、AVL树的区别(延伸话题)"></a>红黑树和二叉排序树、AVL树的区别(延伸话题)</h3><p>二叉排序树</p>
<p>特点:</p>
<ul>
<li>若他的左子树不为空，则他的左子树上所有的值小于根节点的值</li>
<li>若他的右子树不为空，则它的右子树上所有的值大于根节点的值</li>
<li>它的左子树和右子树都是平衡二叉树</li>
<li>中序遍历二叉排序树可以得到一个正序有序的序列</li>
<li>通常情况下，操作时间复杂度为O(logn),极端情况下退化为O(n)</li>
</ul>
<p>这样的数据结构实际上是一个非常典型的适合进行二分法进行查找的结构，每当需要查找元素的时候，先跟根节点比较，就可以判断它在树的哪一端，每次查询都能够缩小一半的候选集，达到时间复杂度为O(logn),但是这里面有个问题，极端情况，如果二叉排序树插入的数据比较极端，比如插入了一组正序有序的数据，使得二叉排序树向右侧单侧倾斜，这时如果查找元素其实就相当于退化成了一个单链表，查找元素的时间复杂度退化为O(n),这种情况下实际上为了提高查找效率就引入了平衡二叉树和红黑树来使得二叉排序树构建的更加平衡。</p>
<p>平衡二叉树(AVL树、高度平衡树)<br>特点：</p>
<ul>
<li>是一种平衡二叉树</li>
<li>每一个节点的左子树和右子树的高度差的绝对值不会超过1<br>平衡二叉树是在构建二叉排序树的过程中，每插入或者删除一个节点，都会先检查是否破坏了树的平衡性，如果是，则找出最小的不平衡的树，通过右旋或者左旋，使之成为新的平衡树</li>
<li>平衡二叉树的插入、查找、删除的时间复杂度是O(logn)</li>
</ul>
<p>平衡二叉树追求的是全局平衡，在插入和删除的时候需要调整整棵树，显然这是很费时的，所以希望在调整的时候，不是整棵树进行结构性调整，而是局部性的调整，这样也就引出了红黑树</p>
<p>红黑树是一种二叉查找树，并在此基础上在每个节点上增加了一个存储位来表示节点的颜色，可以是红色或者黑色，通过对任何一条从根节点到叶子结点的路径的各节点着色方式的限制，确保红黑树没有任何一条路径多于其最短路径的两倍长，这保证了红黑树是大致平衡的，而且又不像平衡二叉树那样要求全局性的平衡</p>
<p>红黑树由以下约束保证了红黑树没有任何一条路径多于其最短路径的两倍长<br>特点：</p>
<ul>
<li>节点是红色或者黑色</li>
<li>根是黑色</li>
<li>所有叶子节点都是黑色</li>
<li>每个红色节点必须有两个黑色的子节点(从每个叶子到根节点的所有路径上不能有两个连续的红色节点)</li>
<li>从任一节点到其每个叶子节点的所有简单路径都包含相同数目的黑色节点</li>
</ul>
<p>在通过插入和删除时，会使得红黑树不再符合红黑树的性质，这时，需要少量(O(logn))的颜色变更和不超过三次的树旋转，牺牲了部分平衡性以换取插入删除时少量的旋转操作，整体性能优于AVL树</p>
<h3 id="ConcurrentHashMap是怎么实现的？"><a href="#ConcurrentHashMap是怎么实现的？" class="headerlink" title="ConcurrentHashMap是怎么实现的？"></a>ConcurrentHashMap是怎么实现的？</h3><h1 id="Java基础之关键字"><a href="#Java基础之关键字" class="headerlink" title="Java基础之关键字"></a>Java基础之关键字</h1><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>作用<br>final可以用来修饰类、方法、变量</p>
<p>修饰类的时候表示该类不能被继承<br>修饰方法的时候表示该方法在子类中不能被重写<br>修饰变量的时候，如果修饰的是基本数据类型，一旦被赋值就不能被再次赋值，如果是引用数据类型，只能保证引用所指向的地址不改变，而引用的对象的属性是可以改变的</p>
<h2 id="String为什么是不可变类-延伸问题"><a href="#String为什么是不可变类-延伸问题" class="headerlink" title="String为什么是不可变类(延伸问题)"></a>String为什么是不可变类(延伸问题)</h2><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h2 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h2><p>既然要聊接口和抽象类的区别，就得先聊一下接口和抽象类分别是什么，他们的共同点，然后再聊区别更容易理解一些。</p>
<p>抽象类概述:</p>
<p>当我们在设计一些行为和属性差不多的类的时候其实可以想到面向对象中的继承，用来抽取一个基类，既可以减少重复代码，又可以让代码变得简洁，抽象类的作用就是如此，用于抽取子类通用属性的一种类，只能用作父类，用于给子类继承并且不能够实例化，作为继承的模板，也是多态的一种表现形式<br>因此我们可以总 结下抽象类的特点</p>
<ul>
<li>不能被实例化，可以有构造函数</li>
<li>可以包含具体方法，也可以包含抽象方法(必须被子类(非抽象子类)实现)</li>
<li>可以包含成员变量和静态成员变量</li>
<li>子类的抽象方法不可以与父类的抽象方法同名</li>
</ul>
<p>接口概述:<br>接口是抽象方法的集合，如果某一个类实现了某个接口，那么他就必须实现这个接口的抽象方法，接口本身并不能做任何事情</p>
<p>接口的特点：</p>
<ul>
<li>接口中不能有构造方法</li>
<li>接口中可以定义”成员变量”,但是会自动转换为 public static final,即Java中的常量，并且必须被显式初始化</li>
<li>接口中的所有方法都是抽象方法，不能包含具体的方法，也不能包含静态的方法(jdk 8可以包含)</li>
<li>不可以通过new来实例化接口</li>
</ul>
<p>有了这些内容，我们就可以来回答接口和抽象类的区别了</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody><tr>
<td>默认的方法实现</td>
<td>可以有</td>
<td>jdk 8之后可以提供，之前不允许有</td>
</tr>
<tr>
<td>关键字</td>
<td>子类通过extends继承抽象类</td>
<td>子类通过implements实现接口</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象方法可以用public protected这些修饰符</td>
<td>接口方法默认public，不可以用其他修饰符</td>
</tr>
<tr>
<td>添加新方法</td>
<td>如果需要往抽象类中添加新的方法，可以提供默认的实现方法，不需要改变现有代码</td>
<td>jdk8以后可以提供默认方法，jdk8之前不可以，所以之前子类必须实现所有接口中的方法</td>
</tr>
<tr>
<td>构造方法</td>
<td>可以有</td>
<td>不可以有</td>
</tr>
<tr>
<td>设计理念</td>
<td>is-a的关系，是一种关系的延续</td>
<td>like-a的关系，体现的是一种功能扩展</td>
</tr>
</tbody></table>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li>修饰成员变量  static可以用来修饰成员变量，也叫静态变量，在内存中只有一个副本，可通过类名访问<br>应用场景:<br>对象间传值</li>
</ul>
<ul>
<li>修饰方法   一般用来抽取工具方法，通过类名直接访问，不可以访问实例变量和实例方法。</li>
<li>修饰代码块  </li>
<li>静态内部类  </li>
<li>静态导入  写代码的时候可以导入某个类或者某个静态方法或静态变量，用来节省代码</li>
</ul>
<h2 id="sychronized怎么用的，里面是怎么实现的？"><a href="#sychronized怎么用的，里面是怎么实现的？" class="headerlink" title="sychronized怎么用的，里面是怎么实现的？"></a>sychronized怎么用的，里面是怎么实现的？</h2><h1 id="Java基础之数据结构"><a href="#Java基础之数据结构" class="headerlink" title="Java基础之数据结构"></a>Java基础之数据结构</h1><h1 id="Java基础之面向对象"><a href="#Java基础之面向对象" class="headerlink" title="Java基础之面向对象"></a>Java基础之面向对象</h1><h2 id="面向对象的特点或者说谈谈面向对象的理解？"><a href="#面向对象的特点或者说谈谈面向对象的理解？" class="headerlink" title="面向对象的特点或者说谈谈面向对象的理解？"></a>面向对象的特点或者说谈谈面向对象的理解？</h2><p>面向过程的特点是封装、继承、多态<br>聊到面向对象其实就不得不提面向过程，</p>
<p>面向过程是一种以事件为中心的变成思想，把解决问题的步骤分析出来，使用函数将这一个个步骤实现，使用的时候直接依次调用即可，简单的问题可以通过面向过程的思路来解决，直接有效，但是问题的规模很大时，面向过程的思想就不太够用了，慢慢的出现了面向对象的编程思想<br>而面向对象是一种以对象为核心的编程思想，把要解决的问题分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个对象在解决问题中步骤中的属性和行为。</p>
<p>面向过程和面向对象的优缺点:</p>
<p>面向过程:<br>优点：</p>
<ul>
<li>流程化，编程任务明确</li>
<li>效率高，面向过程强调代码的短小精悍，善于结合数据结构来开发高效率的程序<br>缺点：<br>需要深入思考，耗费精力，代码重用性差，扩展能力差，后期维护难度较大</li>
</ul>
<p>面向对象：<br>优点：</p>
<ul>
<li>结构清晰，模块化结构化，符合人类思维方式</li>
<li>易扩展，代码重用率高，可继承，可覆盖，可以设计出低耦合的系统</li>
<li>易维护，系统低耦合的特点有利于减少后期维护工作量<br>缺点：</li>
<li>开销大，修改更改对象内部时，对象的属性不允许直接存取，所以需要增加很多无意义，只负责读写的行为，使得编程工作增加负担，增加运行开销，程序变得臃肿</li>
</ul>
<h2 id="Java为什么不支持多继承"><a href="#Java为什么不支持多继承" class="headerlink" title="Java为什么不支持多继承"></a>Java为什么不支持多继承</h2><p>多继承会产生继承的二义性问题，比如B，C同时继承于A；D又多继承于B和C,这时候如果A中定义了一个f()方法，D到底是会调用谁呢？支持多继承的语言像C++是引入了虚继承来解决这个问题的，十分的晦涩难懂，Java的设计者在这里秉持着简单易用的原则，就把类的多继承给移除了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="page-number" href="/blog/page/3/">3</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/blog/images/avatar.jpg" alt="mr_cris">
            
              <p class="site-author-name" itemprop="name">mr_cris</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/blog/archives/">
              
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/blog/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/blog/tags/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mr_cris</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>  总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  














  





  

  

  

  
  

  

  

  

</body>
</html>
